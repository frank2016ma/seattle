[{"content":"在使用脚本语言对Excel文件进行操作时, 有时会发现, 脚本读取出的值和实际在Excel单元格中显示的值不一致的情况 搜索资料后整理出如下笔记\nNumber Format(数字格式) Excel 已经有许多内置的数字格式, 如 货币, 百分比等, 你还可以根据自己的需求设置自定义的数字格式\n Applying a number format only changes how the number is displayed and doesn’t affect cell values that’s used to perform calculations. You can see the actual value in the formula bar.\n应用数字格式只会改变数字的显示方式, 并不会影响用于计算的单元格值. 在公式栏(编辑栏)中可以看到实际的值\n  注意: 公式栏中显示的也不一定是单元格内容的真实值, 有些数字格式, 本身是一种复杂的数据类型, 比如日期, 公式栏中显示的值, 类似编程语言中默认的 toString() 方法的结果, 而对单元格设置数字格式后的显示值, 类似 format() 方法的结果\n 单元格的数字精度问题 当数字的长度达到12位及以上, 会自动以科学计数法显示该数字(仅限Microsoft Excel)\n经实测在WPS表格中, 数字达到12位及以上, 会以文本格式显示该内容(默认靠左对齐, 完整显示内容), 而非科学计数法\n当单元格中的数字长度超过15位时, 会截取15位之后的数字, 全部变成0, 并且在计算时, 使用非精确的数值进行计算\n如, 在单元格中输入 1234567890123456789 回车后, 再查看编辑栏中的数值, 会显示 1234567890123450000\n同样的, 小数部分过长的位数也会被截取\n解决以上问题, 可以使用 添加单引号前缀的方法或者事先将单元格格式设置为文本类型\n Microsoft Excel是根据IEEE 754规范设计的, 以确定它如何存储和计算浮点数.\n然而, IEEE 754规范存在一些限制, 可以分为三个一般类别:\n 最大/最小限制:\nIEEE 754规范对浮点数的表示范围有一定的限制, 它不能表示超出一定范围的数值, 即存在最大值和最小值的限制 精度:\n由于浮点数是用有限的位数来表示, 所以存在精度问题. 在进行一些计算时, 可能会出现舍入误差, 导致结果不够准确. 重复的二进制数:\n由于二进制中一些小数（如1/3）在浮点数表示时是无限循环的, 所以在使用浮点数进行计算时, 可能会出现循环小数的问题.\n这些限制可能会影响在Excel中进行特定类型的计算时的准确性和精度. 为了避免这些问题, 需要在特定情况下谨慎处理浮点数的计算和比较.   格式自动转换  there are scenarios where Excel may automatically change the number format from General to something else, based on the characters that you typed into the cell. This feature saves you from having to manually make the easily recognized number format changes. The following table outlines a few examples where this can occur:\n在某些情况下, Excel会根据你输入到单元格中的字符, 自动将数字格式从常规（General）更改为其他格式. 这个特性省去了手动进行常见数字格式更改的步骤. 以下是几个可能发生这种情况的例子:\n    If you type Excel automatically assigns this number format     1.0 General   1.123 General   1.1% 0.00%   1.1E+2 0.00E+00   1 1/2 # ?/?   $1.11 Currency, 2 decimal places   1/1/01 Date   1:10 Time    解压查看单元格真实值 将xlsx格式解压, 打开 xl/worksheets/sheets.xml 文件可以看到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;sheetData\u0026gt; \u0026lt;row r=\u0026#34;1\u0026#34; spans=\u0026#34;1:6\u0026#34;\u0026gt; \u0026lt;c r=\u0026#34;A1\u0026#34; s=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;v\u0026gt;45132\u0026lt;/v\u0026gt; \u0026lt;/c\u0026gt; \u0026lt;c r=\u0026#34;B1\u0026#34; t=\u0026#34;s\u0026#34;\u0026gt; \u0026lt;v\u0026gt;0\u0026lt;/v\u0026gt; \u0026lt;/c\u0026gt; \u0026lt;c r=\u0026#34;C1\u0026#34;\u0026gt; \u0026lt;v\u0026gt;9\u0026lt;/v\u0026gt; \u0026lt;/c\u0026gt; \u0026lt;c r=\u0026#34;D1\u0026#34; s=\u0026#34;4\u0026#34; t=\u0026#34;s\u0026#34;\u0026gt; \u0026lt;v\u0026gt;1\u0026lt;/v\u0026gt; \u0026lt;/c\u0026gt; \u0026lt;c r=\u0026#34;F1\u0026#34; s=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;v\u0026gt;3.14\u0026lt;/v\u0026gt; \u0026lt;/c\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;row r=\u0026#34;2\u0026#34; spans=\u0026#34;6:6\u0026#34;\u0026gt; \u0026lt;c r=\u0026#34;F2\u0026#34; s=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;v\u0026gt;45.6789\u0026lt;/v\u0026gt; \u0026lt;/c\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;/sheetData\u0026gt;   其中A1单元格中的 45132 就是数字格式的单元格内容储存的实际值, 表示从 1900-01-01 开始的日期天数\ns=\u0026quot;2\u0026quot; 表示在 styles.xml 中引用的样式的下标(下标从0开始), 对应下面的 numFmt 第三个格式标签, 最终在Excel中显示日期为 2023年7月2日\n而B1, D1 中的 0 和 1 并不是单元格的值, B1, D1 中的 t=\u0026quot;s\u0026quot; 表示引用了 sharedStrings.xml, 0 和 1 是引用的 sharedStrings.xml 的下标\n1 2 3 4 5 6 7 8  \u0026lt;numFmts count=\u0026#34;6\u0026#34;\u0026gt; \u0026lt;numFmt numFmtId=\u0026#34;42\u0026#34; formatCode=\u0026#34;_ \u0026#34;￥\u0026#34;* #,##0_ ;_ \u0026#34;￥\u0026#34;* \\-#,##0_ ;_ \u0026#34;￥\u0026#34;* \u0026#34;-\u0026#34;_ ;_ @_ \u0026#34;/\u0026gt; \u0026lt;numFmt numFmtId=\u0026#34;44\u0026#34; formatCode=\u0026#34;_ \u0026#34;￥\u0026#34;* #,##0.00_ ;_ \u0026#34;￥\u0026#34;* \\-#,##0.00_ ;_ \u0026#34;￥\u0026#34;* \u0026#34;-\u0026#34;??_ ;_ @_ \u0026#34;/\u0026gt; \u0026lt;numFmt numFmtId=\u0026#34;176\u0026#34; formatCode=\u0026#34;yyyy\u0026#34;年\u0026#34;m\u0026#34;月\u0026#34;d\u0026#34;日\u0026#34;;@\u0026#34;/\u0026gt; \u0026lt;numFmt numFmtId=\u0026#34;177\u0026#34; formatCode=\u0026#34;0.000###\u0026#34;/\u0026gt; \u0026lt;numFmt numFmtId=\u0026#34;41\u0026#34; formatCode=\u0026#34;_ * #,##0_ ;_ * \\-#,##0_ ;_ * \u0026#34;-\u0026#34;_ ;_ @_ \u0026#34;/\u0026gt; \u0026lt;numFmt numFmtId=\u0026#34;43\u0026#34; formatCode=\u0026#34;_ * #,##0.00_ ;_ * \\-#,##0.00_ ;_ * \u0026#34;-\u0026#34;??_ ;_ @_ \u0026#34;/\u0026gt; \u0026lt;/numFmts\u0026gt;   VBA 首先需要注意的是, 真实值和显示值是Office软件实现的(如 Excel, WPS), 而非VBA\n使用VBA可以获取Excel单元格的真实值和显示值\n使用 .Value2 或者.Value 和可以获取单元格内容的真实值(此处暂不讨论.Value2和.Value的区别), 真实值会被转化成VBA的数据类型\n使用.Text 获取单元格的显示值, 显示值是所见即所得的(WYSIWYG), 在Excel单元格中看到是什么内容, VBA读出的就是什么内容, 显示值的数据类型是 String\nVBA 数据处理应该避免使用显示值 在使用VBA进行自动化表格处理时, 应该避免使用 .Text 获取单元格显示值来进行处理\n影响显示值的因素有很多, 显示值会受到单元格宽度, 单元格的数字格式, 甚至是国家地区等因素的影响\n  当在单元格中设置输入日期, 当单元格宽度足够时, 会显示完整日期, 缩短单元格长度, 无法完整显示日期文本时候, 单元格的显示值就变成了一组由 \u0026lsquo;#\u0026rsquo; 组成的符号(#号的数量取决于单元格长度)\n  常规格式下, 单元格中数字长度达到12位及以上时, 显示值会变成科学计数法(MS-Excel中)\n  在中国, 数字 123456789, 设置为 金额格式, 则显示值为 123,456,789.00, 前面还会加上货币符号 ￥, 而在某些国家, 如德国巴西等, 千分位分隔符和小数点的表示方法是相反的, 金额格式会显示为 123.456.789,00\n  Python openpyxl openpyxl 中并没有显示值的概念, 因为 openpyxl 只是一个python库, 而真实值显示值的概念, 是在Office软件中实现的\n所以, 使用Python(openpyxl或其他库)无法获取单元格的显示值\n举一个例子, 一份 Excel 文件就像一个代码文件 xxxx.py, 而Office软件就像是IDE或者代码编辑器, 如 PyCharm, 代码文件本身只是一个普通的文本文件, 而代码的高亮显示, 自动提示等功能, 其实是由IDE提供的\n它只能获取单元格的真实值以及数字格式, 无法获取对这个值设置对应数字格式之后的显示值\n使用python时, 可以通过编写自定义函数的方式, 将真实值格式化为指定的数值格式\n单引号 在单元格输入中, 在要输入的内容开头添加单引号', 会强制将输入的内容作为文本处理, 且使用脚本读取时, VBA 和 Python 都会忽略前面的单引号, 从而能够保证读取的内容和输入的内容完全一致(除了单引号前缀), 且单引号的优先级高于数字格式及单元格宽度等, 改变数字格式不会改变读取值\nKeeping leading zeros and large numbers - Microsoft Support\n如果在单元格开头插入单引号本身而不是作为文本标识符号转义, 可以参考下方链接中的做法 How to Add Single Quotes in Excel (5 Easy Methods) - ExcelDemy\n excel - What is the difference between .text, .value, and .value2? - Stack Overflow\nAvailable number formats in Excel - Microsoft Support\nFormat numbers as currency - Microsoft Support\nControl settings in the Format Cells dialog box - Office | Microsoft Learn\nLast digits are changed to zeros when you type long numbers in cells of Excel - Office | Microsoft Learn\n","date":"2023-07-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/excel/excel-realvalue-displayvalue/","title":"关于 Excel 单元格数字格式、真实值和显示值"},{"content":"DataFrame 写入 Excel 文件 下面两段代码用于直接生成 Excel 文件, 如果文件已经存在, 会被覆盖\n1 2 3 4 5 6 7 8 9 10 11  # sht2, sht3 两张表都会被写入 with pd.ExcelWriter(path=r\u0026#39;path_to_file.xlsx\u0026#39;) as writer: df.to_excel(ew, sheet_name=\u0026#39;sht2\u0026#39;, index=False) df.to_excel(ew, sheet_name=\u0026#39;sht3\u0026#39;, index=False) # 第二次会覆盖掉第一次的 # 只剩下 sht3 with pd.ExcelWriter(path=r\u0026#39;path_to_file.xlsx\u0026#39;) as writer: df.to_excel(ew, sheet_name=\u0026#39;sht2\u0026#39;, index=False) with pd.ExcelWriter(path=r\u0026#39;path_to_file.xlsx\u0026#39;) as writer: df.to_excel(ew, sheet_name=\u0026#39;sht3\u0026#39;, index=False)    DataFrame 追加写入 Excel 文件 如果要往一份已经存在的Excel文件中追加内容, 如往含有标题的模板中填写数据或者在已有数据末尾追加数据\npandas 1.4.0之前的版本 在 pandas 1.4.0 之前, 可以使用如下方法将 DataFrame 追加写入 Excel 文件\n首先需要指定 engine 为 openpyxl(pandas 写Excel文件默认使用的库是xlsxwriter, 不支持追加写入)\n1 2 3 4 5 6 7 8 9 10 11  from openpyxl import load_workbook wb = load_workbook(file_path) with pd.ExcelWriter(file_path, engine=\u0026#39;openpyxl\u0026#39;) as writer: # 指定 workbook 对象 writer.book = wb writer.sheets = dict((ws.title, ws) for ws in wb.worksheets) # 或者可以用表达式的写法 writer.sheets = {ws.title: ws for ws in wb.worksheets} df.to_excel(writer, sheet_name=sht_name, index=False, header=False, startrow=len(book)+1, )   pandas 1.4.0及之后的版本 在 pandas 1.4.0 之后, to_excel() 函数的 if_sheet_exists 新增了overlay属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026#39;\u0026#39;\u0026#39; if_sheet_exists : {{\u0026#39;error\u0026#39;, \u0026#39;new\u0026#39;, \u0026#39;replace\u0026#39;, \u0026#39;overlay\u0026#39;}}, default \u0026#39;error\u0026#39; How to behave when trying to write to a sheet that already exists (append mode only). * error: raise a ValueError. * new: Create a new sheet, with a name determined by the engine. * replace: Delete the contents of the sheet before writing to it. * overlay: Write contents to the existing sheet without removing the old contents. versionadded:: 1.3.0 versionchanged:: 1.4.0 Added `overlay` option You can also write multiple DataFrames to a single sheet. Note that the ``if_sheet_exists`` parameter needs to be set to ``overlay``: with ExcelWriter(\u0026#34;path_to_file.xlsx\u0026#34;, mode=\u0026#34;a\u0026#34;, engine=\u0026#34;openpyxl\u0026#34;, if_sheet_exists=\u0026#34;overlay\u0026#34;, ) as writer: df1.to_excel(writer, sheet_name=\u0026#34;Sheet1\u0026#34;) df2.to_excel(writer, sheet_name=\u0026#34;Sheet1\u0026#34;, startcol=3) \u0026#39;\u0026#39;\u0026#39;   对于pandas 1.4.0 及以上的版本, 可以使用下面的方法来追加写入\n首先, 依然是设置engine为 openpyxl\n然后, 设置 if_sheet_exists=\u0026quot;overlay\u0026quot; 的同时, 还需要设置 mode=\u0026quot;a\u0026quot; 表示追加写入\n1 2 3 4 5 6 7  with ExcelWriter(\u0026#34;path_to_file.xlsx\u0026#34;, mode=\u0026#34;a\u0026#34;, engine=\u0026#34;openpyxl\u0026#34;, if_sheet_exists=\u0026#34;overlay\u0026#34;, ) as writer: df1.to_excel(writer, sheet_name=\u0026#34;Sheet1\u0026#34;) df2.to_excel(writer, sheet_name=\u0026#34;Sheet1\u0026#34;, startcol=3)    Append existing excel sheet with new dataframe using python pandas - Stack Overflow\npython - append dataframe to excel with pandas - Stack Overflow\n","date":"2023-07-12T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python/pandas-append-range-to-sheet/","title":"Pandas 追加写入 Excel 表格"},{"content":"Introducing websocket 的最大特点就是, 服务器可以主动向客户端推送消息, 客户端也可以主动向服务器发送消息\n While a WebSocket connection is functionally somewhat similar to standard Unix-style sockets, they are not related.\n 尽管 WebSocket 连接 在功能上和 标准的 Unix 风格的socket 类似, 但是这两者之间并没有关联\n为什么需要websocket HTTP 协议有一个缺陷, 通信只能有客户端发起\njs客户端websocket 构造函数创建websocket实例 1  const exampleSocket = new WebSocket(\u0026#34;wss://www.example.com/socketserver\u0026#34;);   websocket.readyState  0: CONNECTING 1: OPEN 2: CLOSING 3: CLOSED  指定回调函数 oncode, onmessage, readState 等是 属性()\nsend(), close() 是方法\nonopen 1 2 3  ws.onopen = () =\u0026gt; { ws.send(\u0026#39;Hello Server\u0026#39;); }   如果要指定多个回调函数, 可以使用addEventListener方法\n1 2 3  ws.addEventListener(\u0026#39;open\u0026#39;, (event) =\u0026gt; { ws.send(\u0026#39;Hello again\u0026#39;); })   onmessage 用于指定 收到服务器数据之后的回调函数, 服务器数据可能是文本, 看也可能是二进制数据(blob对象或者Arraybuffer对象)\n1 2 3 4 5 6 7 8  ws.onmessage = function(event){ if(typeOf event.data === String) { console.log(\u0026#34;Received data string\u0026#34;) } if(event.data instanceof ArrayBuffer){ console.log(\u0026#34;Received arraybuffer\u0026#34;) } }   Send data to server 1 2 3 4 5 6 7 8 9 10  exampleSocket.send(\u0026#34;Here\u0026#39;s some text that the server is urgently awaiting!\u0026#34;); // You can send data as a string, Blob, or ArrayBuffer.  const msg = { type: \u0026#34;message\u0026#34;, text: document.getElementById(\u0026#34;text\u0026#34;).value, id: clientID, date: Date.now(), }; exampleSocket.send(JSON.stringify(msg));   Receiving messages from server WebSockets is an event-driven API; when messages are received, a message event is sent to the WebSocket object. To handle it,\n add an event listener for the message event use the onmessage event handler  1 2 3  exampleSocket.onmessage = (event) =\u0026gt; { console.log(event.data); };    Writing WebSocket client applications - Web APIs | MDN\n","date":"2023-06-26T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/websocket/","title":"WebSocket"},{"content":"Mixin (mix-in), 是一种编程模式, 和多重继承类似\n首先，需要注意的是混合（Mixin）仅存在于支持多重继承的编程语言中。在Java或C#等不支持多重继承的语言中，无法直接使用混合。\n在不支持混合的语言中，可以使用其他替代方法来达到类似的效果。 例如，在Java中，可以通过接口（Interface）和委托（Delegation）等技术来实现一些混合的特性。接口允许类实现多个接口以获取不同的功能，而委托则允许类将某些功能委托给其他对象来实现。\n然而，在真正的混合模式中，通过多重继承可以直接将多个类的功能组合到一个类中，而不需要接口或委托的复杂处理。 因此，在只支持单一继承的语言中，实现类似混合的功能可能会更加繁琐和复杂。\n在 Python 等面向对象语言中，通常它是实现了某种功能单元的类，用于被其他子类继承，将功能组合到子类中\n当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 Mixin 类\n在面向对象编程语言中，混合（Mixin）是一个包含方法的类，其他类可以使用这些方法，而无需将其作为父类。 其他类如何访问混合类的方法取决于所使用的编程语言。有时，混合类被描述为\u0026quot;被包含\u0026quot;而不是\u0026quot;被继承\u0026quot;。 混合类的主要目的是通过提供可重用的功能和行为来增强其他类，而无需创建复杂的继承关系。通过混合，类可以在不增加继承层次结构的同时获得新的方法和特性，提供了更大的灵活性和可复用性。混合是一种常见的编程技术，被广泛应用于许多面向对象编程语言中。\nMixin 是一种特殊的多重继承方式。混合通常用于以下两种主要情况：\n当您希望为一个类提供许多可选功能时，可以使用 Mixin。 当您希望在许多不同的类中使用某个特定功能时，可以使用 Mixin。\n Python mixin\npython - What is a mixin and why is it useful? - Stack Overflow\nMixin - Wikipedia\n","date":"2023-06-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python/docs/mixin/","title":"Mixin"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  import tkinter as tk from tkinter import messagebox from PIL import ImageTk, Image import os # 定义字符映射表 # 不懂区间的灰度值对应不同的字符 CHARS = \u0026#39;@%#*+=-:. \u0026#39; class ImageViewer: def __init__(self): self.window = tk.Tk() self.window.title(\u0026#34;主窗口\u0026#34;) self.source_file_path = \u0026#39;\u0026#39; self.create_widgets() def create_widgets(self): # 图像文件路径 self.entry = tk.Entry(self.window, width=50) self.entry.pack(pady=10) self.button_open_image = tk.Button( self.window, text=\u0026#34;打开图像\u0026#34;, command=self.open_image) self.button_open_image.pack(pady=5) self.image_label = tk.Label(self.window) self.image_label.pack() self.button_convert = tk.Button( self.window, text=\u0026#34;转换为灰度图\u0026#34;, command=self.convert_to_grayscale) self.button_convert.pack() self.button_convert = tk.Button( self.window, text=\u0026#34;转换为字符画\u0026#34;, command=self.convert_to_ascii) self.button_convert.pack() self.text_ascii = tk.Text(self.window, width=200, height=200) self.text_ascii.pack() def show_image(self): photo = ImageTk.PhotoImage(self.image) self.image_label.configure(image=photo) self.image_label.image = photo def show_ascii(self): self.text_ascii.delete(\u0026#39;1.0\u0026#39;, tk.END) self.text_ascii.insert(tk.END, self.ascii_str) def open_image(self): self.source_file_path = self.entry.get().strip(\u0026#39;\u0026#34;\u0026#39;) try: # pillow读取图片 self.image = Image.open(self.source_file_path) self.image.thumbnail((400, 400)) self.show_image() except Exception as e: if self.source_file_path == \u0026#34;\u0026#34;: messagebox.showwarning(title=\u0026#39;警告\u0026#39;, message=f\u0026#34;请输入文件路径\u0026#34;) elif not os.path.exists(self.source_file_path): messagebox.showwarning( title=\u0026#39;警告\u0026#39;, message=f\u0026#34;文件 {self.source_file_path}不存在\u0026#34;) print(f\u0026#34;无法打开图像文件: {e}\u0026#34;) def convert_to_grayscale(self): \u0026#34;\u0026#34;\u0026#34;图片转换为灰度图\u0026#34;\u0026#34;\u0026#34; self.image = self.image.convert(\u0026#39;L\u0026#39;) self.show_image() def convert_to_ascii(self, width=200, chars=CHARS): # 调整图像尺寸 w, h = self.image.size print(self.image.size) aspect_ratio = h / w # 字符的宽高比, 因为ASCII字符都是半角的(大部分字体), 所以需要再除以 2 new_height = int(width * aspect_ratio / 2) # 调整大小 resized_image = self.image.resize((width, new_height)) print(resized_image.size) ascii_str = \u0026#39;\u0026#39; # 根据像素点的灰度值转换为字符画 for y in range(new_height): for x in range(width): # 获取像素的亮度值 brightness = resized_image.getpixel((x-1, y-1)) # 根据亮度值映射到字符集中的字符 char_index = int(brightness / 256 * len(chars)) ascii_str += chars[char_index] # 添加换行符 ascii_str += \u0026#39;\\n\u0026#39; self.ascii_str = ascii_str self.show_ascii() def run(self): self.window.mainloop() def main(): # 创建ImageViewer对象并运行 viewer = ImageViewer() viewer.run()   ","date":"2023-06-23T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python/image2ascii/","title":"Image2ASCII"},{"content":"原理 实现一个多人聊天室需要两个部分, client 端 和server 端\nclient 端只和server端进行通信, 不同的client之间是不会直接通信的\n实现需要两个核心的库, socket 和 threading\nsocket 用来实现网络中的多个节点并进行通信\nthreading 模块用于支持多线程(python有全局解释锁, 所以是伪多线程)\nServer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  class ChatServer: def __init__(self, host, port) -\u0026gt; None: self.host = host self.port = port self.server_socket = None # 客户端列表 self.client_sockets = [] self.client_usernames = [] self.lock = threading.Lock() def start(self): # family=AF_INET - IPv4地址 # type=SOCK_STREAM - TCP套接字 self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) self.server_socket.bind((self.host, self.port)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 self.server_socket.listen(5) print(f\u0026#34;Server started on {self.host}:{self.port}\u0026#34;) # 持续监听输入 while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # client_socket 是客户端对象 # address 是连接到服务器的客户端的地址(由IP和端口两部分构成) # 首先判断是否已经被关闭 if getattr(self.server_socket, \u0026#39;_closed\u0026#39;, True): break try: client_socket, address = self.server_socket.accept() except OSError: print(\u0026#34;close the chat room\u0026#34;) break self.client_sockets.append(client_socket) threading.Thread(target=self.handle_client, args=(client_socket,)).start() def handle_client(self, client_socket): \u0026#34;\u0026#34;\u0026#34; 处理客户端发起会话 \u0026#34;\u0026#34;\u0026#34; # 用户加入 # recv(bufsize) 接收TCP数据, 返回bytes, 需要decode, bufsize 表示一次接受的最大数据量, 为2的N次方 username = client_socket.recv(1024).decode() self.client_usernames.append(username) self.broadcast(f\u0026#34;{username}has joined the chat.\u0026#34;) while True: try: message = client_socket.recv(1024).decode() if message: self.broadcast(f\u0026#34;{username}: {message}\u0026#34;) else: self.remove_client(client_socket) break except Exception as e: print(e) self.remove_client(client_socket) break def remove_client(self, client_socket): \u0026#34;\u0026#34;\u0026#34; 退出群聊 \u0026#34;\u0026#34;\u0026#34; index = self.client_sockets.index(client_socket) username = self.client_usernames[index] self.client_sockets.remove(client_socket) self.client_usernames.remove(username) client_socket.close() self.broadcast(f\u0026#34;{username}has left the chat.\u0026#34;) # 当聊天室所有成员退出聊天室之后, 关闭聊天室 if len(self.client_sockets) == 0: print(\u0026#34;All users have exited the chat room.\u0026#34;) self.stop() def broadcast(self, message): \u0026#34;\u0026#34;\u0026#34; 广播消息, 聊天室内所有人都可以看到消息 \u0026#34;\u0026#34;\u0026#34; with self.lock: for client_socket in self.client_sockets: client_socket.send(message.encode()) def stop(self): \u0026#34;\u0026#34;\u0026#34; 终止server \u0026#34;\u0026#34;\u0026#34; self.server_socket.close()   Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  class ChatClient: def __init__(self, host, port): # 客户端核心内容 self.host = host self.port = port self.client_socket = None self.username = None # 以下为GUI部分(非必须, 只通过命令行也可以实现聊天部分) # 主窗体 self.root = tk.Tk() self.root.title(\u0026#34;Chat Room\u0026#34;) self.root.protocol(\u0026#39;WM_DELETE_WINDOW\u0026#39;, self.disconnect) # 消息面板 self.message_frame = tk.Frame(self.root) self.scrollbar = tk.Scrollbar(self.message_frame) # 展示聊天消息列表 self.message_list = tk.Listbox(self.message_frame, height=20, width=50, yscrollcommand=self.scrollbar.set) self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y) self.message_list.pack(side=tk.LEFT, fill=tk.BOTH) self.message_frame.pack() # 输入面板 self.input_frame = tk.Frame(self.root) # 输入框用于输入消息 self.message_entry = tk.Entry(self.input_frame, width=50) self.message_entry.pack(side=tk.LEFT) # 发送消息按钮 self.send_button = tk.Button(self.input_frame, text=\u0026#34;Send\u0026#34;, command=self.send_message) self.send_button.pack(side=tk.LEFT) self.input_frame.pack() def connect(self): self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.client_socket.connect((self.host, self.port)) self.username = self.prompt_username() self.client_socket.send(self.username.encode()) threading.Thread(target=self.receive_messages).start() self.root.mainloop() def prompt_username(self): while True: # 对话框要求输入用户名 username = simpledialog.askstring(\u0026#39;input\u0026#39;, \u0026#39;input your username\u0026#39;) if username: return username def send_message(self): message = self.message_entry.get() self.client_socket.send(message.encode()) # 发送消息后, 清空消息输入框 self.message_entry.delete(0, tk.END) def receive_messages(self): while True: try: message = self.client_socket.recv(1024).decode() self.message_list.insert(tk.END, message) self.message_list.see(tk.END) except Exception as e: print(e) break def disconnect(self): self.client_socket.close() self.root.destroy()   ","date":"2023-06-23T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python/chat-room/","title":"python 实现简易多人聊天室"},{"content":"React apps are made out of components A component is a piece of the UI(user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page\n React component names must always start with a capital letter, while HTML tags must be lowercase.\n writing markup with JSX 1 2 3 4 5  export default function MyApp(){ return ( \u0026lt;div\u0026gt;MyApp\u0026lt;/div\u0026gt; ) }   The export default keywords specify the main component in the file. export default有点类似main函数\nThe rules of JSX  Return a single root element close all Tags camelCase most of the things  Displaying data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  const user = { name: \u0026#39;frank\u0026#39;, imageUrl: \u0026#39;\u0026#39;, imageSize: 90, }; export default function Profile(){ \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;{user.name}\u0026lt;/h1\u0026gt; \u0026lt;img className=\u0026#34;avatar\u0026#34; src={user.imageUrl} alt={\u0026#39;Photo of \u0026#39; + user.name} style={{ width:user.imageSize, height:user.imageSize }} /\u0026gt; \u0026lt;/\u0026gt; } // style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces.   Updating the screen 1 2 3 4 5  import { userState } from \u0026#39;react\u0026#39;; function MyButton() { const [count, setCount] = userState(0); // }    You’ll get two things from useState: the current state (count), and the function that lets you update it (setCount)\n  You can give them any names, but the convention is to write [something, setSomething]\n [something, setSomething] 是约定俗成的写法, 并不是严格要求\nUsing Hooks Function starting with use are called Hooks, useState is a built-in Hook provided by React.\nYou can only call Hooks at the top of your components(or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there.\ncurly braces where to use curly braces  As text directly inside a JSX tag As attributes immediately following the = sign  src={avatar} √ src=\u0026quot;{avatar}\u0026quot; ×\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const baseUrl = \u0026#39;https://i.imgur.com/\u0026#39;; const person = { name: \u0026#39;Gregorio Y. Zara\u0026#39;, imageId: \u0026#39;7vQD0fP\u0026#39;, imageSize: \u0026#39;s\u0026#39;, theme: { backgroundColor: \u0026#39;black\u0026#39;, color: \u0026#39;pink\u0026#39; } }; export default function TodoList() { return ( \u0026lt;img className=\u0026#34;avatar\u0026#34; src = {baseUrl + person.imageId + person.imageSize + \u0026#39;.jpg\u0026#39;} /\u0026gt; ) }   Any JavaScript expression will work between curly braces, including function calls like formatDate()\n1 2 3 4 5 6 7 8 9 10 11 12 13  const today = new Date() function formatDate(date){ return new Intl.DateTimeFormat( \u0026#39;en-US\u0026#39;, {weekday: \u0026#39;long\u0026#39;} ).format(date); } export default function TodoList() { return ( \u0026lt;h1\u0026gt;To Do List for {formatDate(today)}\u0026lt;/h1\u0026gt; ) }    passing props to a component pass props to child component 1 2 3 4 5 6 7 8  export default function Profile() { return ( \u0026lt;Avatar person={{name:\u0026#39;Frank Ma\u0026#39;, age: 25}} size={100} /\u0026gt; ); }   read props inside the child component 1 2 3  function Avatar({ person, size}) { // person and size are available here }   passing JSX as children 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import Avatar from \u0026#39;./Avatar.js\u0026#39;; function Card({ children }) { return ( \u0026lt;div className=\u0026#34;card\u0026#34;\u0026gt; {children} \u0026lt;/div\u0026gt; ); } export default function Profile() { return ( \u0026lt;Card\u0026gt; \u0026lt;Avatar size={100} person={{ name: \u0026#39;Katsuko Saruhashi\u0026#39;, imageId: \u0026#39;YfeOqp2\u0026#39; }} /\u0026gt; \u0026lt;/Card\u0026gt; ); }   条件渲染 1 2 3 4 5 6  function Item({ name, isPacked }) { if (isPacked) { return \u0026lt;li className=\u0026#34;item\u0026#34;\u0026gt;{name} ✔\u0026lt;/li\u0026gt;; } return \u0026lt;li className=\u0026#34;item\u0026#34;\u0026gt;{name}\u0026lt;/li\u0026gt;; }    Quick Start – React\n","date":"2023-06-14T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/react/quick-start/","title":"Quick Start"},{"content":"sed 语法 sed [options]... [script] [input-file]\nsed 默认输入输出为 stdin, stdout\n sed treats multiple input files as one long stream. The following example prints the first line of the first file (one.txt) and the last line of the last file (three.txt). Use -s to reverse this behavior. 下面的命令中, sed 将 one two three 三个文件当作一个输入, 所以只会输出 one文件的第一行和 three 文件的最后一行\n sed -n '1p ; $p' one.txt two.txt three.txt\noptions -n --quiet\nBy default sed prints all processed input (except input that has been modified/deleted by commands such as d). Use -n to suppress output, and the p command to print specific lines. The following command prints only line 45 of the input file:\n-i --in-place\n修改文件并备份原文件\nsed -i.bak 's/foo/bar/g' file.txt等于```sed \u0026ndash;in-place=.bak \u0026rsquo;s/foo/bar/g' file.txt`\n以上命令会修改 file.txt 文件的内容, 并且备份原文件为 file.txt.bak\nsed -i 's/foo/bar/g' file.txt 则会直接修改 file.txt 文件\n1 2 3 4 5 6 7 8  # 从文件中读取脚本 sed -f myscript.sed input.txt # -e 指定脚本, 通常可省略 sed \u0026#39;s/hello/world/\u0026#39; input.txt sed -e \u0026#39;s/hello/world/\u0026#39; input.txt sed --expression=\u0026#39;s/hello/world/\u0026#39; input.txt # -e 参数可以连续使用 sed -e \u0026#39;/^foo/d\u0026#39; -e \u0026#39;s/hello/world/\u0026#39; input.txt   -s --separate\n上面提到过, sed会将多个文件合并成一个输入, 使用-s命令可以将它们拆分视为多个输入\nscript 语法 [addr]X[options]\nX 表示一个sed 命令字母\n[addr] addr 表示行地址, 可以是行号, 正则表达式, 也可以是地址范围\n行号 sed '144s/hello/world/' input.txt\n将第144行的hello替换成world\n$ 表示最后一行\nn~step\n第n行开始的每隔step行\n1 2 3 4 5 6 7 8 9  seq 10 | sed -n \u0026#39;0~4p\u0026#39; 4 8 seq 10 | sed -n \u0026#39;1~3p\u0026#39; 1 4 7 10   正则表达式 /regexp/ sed '/apple/s/hello/world/' input.txt 将包含apple的行 的hello 替换成 world\n如果要匹配的字符串本身包含 斜杠/, 可以用其他符号代替斜杠(通常是%), 这样可以避免频繁使用 \\ 来转义 /\n下面三种写法都是匹配 以/home/alice/documents/开头的行\n1 2 3  sed -n \u0026#39;/^\\/home\\/alice\\/documents\\//p\u0026#39; sed -n \u0026#39;\\%^/home/alice/documents/%p\u0026#39; sed -n \u0026#39;\\;^/home/alice/documents/;p\u0026#39;   /regexp/M 多行匹配模式 地址范围 addr1, +N 匹配第addr1行及后面的N行\n1 2 3 4  seq 10 | sed -n \u0026#39;6,+2p\u0026#39; 6 7 8   sed '4,17s/hello/world/' input.txt 从第4行到第17行的hello 替换成world(左闭右闭)\n! 反向匹配  sed '/apple/!s/hello/world/' input.txt 将不包含apple的行 的hello 替换成 world\n地址范围  sed '4,17s/hello/world/' input.txt 将除了从第4行到第17行的所有行的hello 替换成world\ncommands(X) a (在addr后面添加内容) 1 2 3 4 5  seq 3 | sed \u0026#39;2a hello\u0026#39; 1 2 hello 3   i (在addr前面插入内容) c (替换addr整行内容) 1 2 3 4  seq 10 | sed \u0026#39;2,9c hello\u0026#39; 1 hello 10   p (输出addr行的内容, 配合-n使用) y/src/dst/ (映射替换) 1 2  echo hello world | sed \u0026#39;y/abcdefghij/0123456789/\u0026#39; # 74llo worl3   s/regexp/replacement/[flags] (替换文本) [flags]   g, 全局匹配\n  [number], 仅替换第n个匹配的字符串\n   examples 以下的替换、追加及删除操作, 是不会修改原文件的, 修改文件需要加上-i参数\n查找 sed -n '/hello/p' file.txt\n修改文件并备份原文件\nsed -i.bak 's/foo/bar/g' file.txt\n以上命令会直接修改 file.txt 文件的内容, 并且备份原文件为 file.txt.bak\n-i 的意思是 inplace\n替换文本 1 2 3  sed \u0026#39;s/old/new/g\u0026#39; file.txt # s 表示执行替换操作 # g 表示全局替换   追加行 1 2 3 4 5 6 7 8 9  sed \u0026#39;$a THE END!\u0026#39; file.txt # $ 表示最后一行 # a 表示追加行 # \u0026#39;THE END\u0026#39; 表示 要追加内容 # 并不会修改 file.txt 中的内容, 如果 sed \u0026#39;2 i new-line\u0026#39; input.txt # 在第二行前面插入 \u0026#39;new-line\u0026#39; sed \u0026#39;2 a new-line\u0026#39; input.txt # 在第二行前面插入 \u0026#39;new-line\u0026#39;   删除行 删除第5到7行\n1  sed \u0026#39;5,7d\u0026#39; file.txt   删除第5行和第7行\n1  sed \u0026#39;5d;7d\u0026#39; file.txt   1 2  # 删除 \u0026#39;Hello\u0026#39; 开头的所有行, 区分大小写 sed \u0026#39;/^Hello/d\u0026#39; file.txt    sed, a stream editor\nlinux - The Concept of \u0026lsquo;Hold space\u0026rsquo; and \u0026lsquo;Pattern space\u0026rsquo; in sed - Stack Overflow\n","date":"2023-06-10T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/sed-cheat-sheet/","title":"Sed 速查表"},{"content":"展开语法(Spread syntax) 在函数调用/数组构造时, 将数组表达式或者string在语法层面展开; 还可以在构造字面量时, 将对象按照 key-value 的方式展开\n语法 myFunction(\u0026hellip;iterableObj);\n实例 在函数调用时使用展开语法 等价于apply 1 2 3 4 5 6  function myFunction(x, y, z) {}; var args = [0, 1, 2] myfunction.apply(null, args); // 使用展开语法 myfunction(...args)   构造字面量数组 1 2 3 4 5 6 7 8  var parts = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;] var fruits = [\u0026#39;pear\u0026#39;, ...parts, \u0026#39;watermelon\u0026#39;] var arr = [1, 2, 3] var arr2 = [...arr] // like arr.slice() arr2.push(4) // arr2: [1, 2, 3, 4] // arr 不变   ","date":"2023-06-08T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/spread-syntax/","title":"Spread Syntax"},{"content":"xargs命令的作用，是将标准输入转为命令行参数(使用xargs的原因是, 很多命令不支持标准输入传递参数, 如echo, ls)\n默认情况下, xargs将换行符和空格作为分隔符, 把标准输入分解成一个个命令行参数\n-d 参数可以更改分隔符 input file names are terminated by the specified character delim instead of by whitespace\n-L max-lines Use at most max-lines non-blank input lines per command line. for -L the argument is mandatory. Trailing blanks cause an input line to be logically continued on the next input line The -l form of this option is deprecated in favour of the POSIX-compliant -L option.\n-n max-args Use at most max-args arguments per command line\n-I 指定每一项命令行参数的替代字符串 replace occurrences of replace-str in the initial arguments with names read from standard input.\nthe -i option is deprecated in favour of the -I option\n-t print the command line on the standard error output before executing it\n1 2 3 4 5 6  # 列出当前文件夹下文件内容包含 \u0026#39;drafts\u0026#39; 的文件并移动到 /root/ 文件夹下 grep -rl \u0026#39;drafts\u0026#39; . | xargs mv -t /root/ # 复制所有图片文件到 /data/images 目录下 ls *.jpg | xargs -n1 -I {} cp {} /data/images   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # xargs # Execute a command with piped arguments coming from another command, a file, etc. # The input is treated as a single block of text and split into separate pieces on spaces, tabs, newlines and end-of-file. # More information: \u0026lt;https://pubs.opengroup.org/onlinepubs/9699919799/utilities/xargs.html\u0026gt;. # Run a command using the input data as arguments: arguments_source | xargs command # Run multiple chained commands on the input data: arguments_source | xargs sh -c \u0026#34;command1 \u0026amp;\u0026amp; command2 | command3\u0026#34; # Delete all files with a `.backup` extension (`-print0` uses a null character to split file names, and `-0` uses it as delimiter): find . -name \u0026#39;*.backup\u0026#39; -print0 | xargs -0 rm -v # Execute the command once for each input line # replacing any occurrences of the placeholder (here marked as `_`) with the input line: arguments_source | xargs -I _ command _ optional_extra_arguments    xargs 命令教程 - 阮一峰的网络日志\nxargs options (GNU Findutils 4.9.0)\nLinux xargs 命令 | 菜鸟教程\n","date":"2023-06-08T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/xargs-cheatsheet/","title":"Xargs 速查表"},{"content":"回调函数是异步操作最基本的方法\n1 2 3 4 5 6 7 8 9 10 11  function f1(callback) { // ...  callback(); } function f2() { // ... } f1(f2); // 把 f2 写成 f1 的回调函数   sedTimeout(func|code, delay) 一段时间之后执行某个函数或某段代码\nsetInterval(func|code, delay) 每隔一段时间就执行一次\nPromise含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\nPromise对象有以下两个特点。\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n语法 1 2 3 4 5 6 7 8 9  const promise = new Promise(function(resolve, reject) { // ... some code  if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } });   Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\n Promise 对象 - ECMAScript 6入门\n","date":"2023-06-06T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/promise/","title":"Promise"},{"content":"axios install  npm install axios \u0026lt;script src=\u0026quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;https://unpkg.com/axios/dist/axios.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  example 1 2 3 4 5 6 7 8 9 10 11 12  axios.get(\u0026#39;/user?ID=12345\u0026#39;) .then(function (response) { // handle success  console.log(response); }) .catch(function (error) { // handle error  console.log(error); }) .finally(function () { // always executed  });   ","date":"2023-06-05T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/axios-cheat-sheet/","title":"Axios 速查表"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  import { useState } from \u0026#39;react\u0026#39;; /* React provides a special function called useState that you can call from your component to let it “remember” things. Let’s store the current value of the Square in state, and change it when the Square is clicked. */ // 九宫格 单个宫格 // value: X, O, null function Square({ value, onSquareClick }) { return ( \u0026lt;button className=\u0026#34;square\u0026#34; onClick={onSquareClick}\u0026gt; {value} \u0026lt;/button\u0026gt; ); } function Board({ xIsNext, squares, onPlay }) { function handleClick(i) { // 如果已经判定胜负, 或者被点击的单元格已经被点击过, 不做处理  if (calculateWinner(squares) || squares[i]) { return; } // 点击后的棋盘  const nextSquares = squares.slice(); if (xIsNext) { nextSquares[i] = \u0026#39;X\u0026#39;; } else { nextSquares[i] = \u0026#39;O\u0026#39;; } onPlay(nextSquares); } const winner = calculateWinner(squares); let status; if (winner) { status = \u0026#39;Winner: \u0026#39; + winner; } else { status = \u0026#39;Next player: \u0026#39; + (xIsNext ? \u0026#39;X\u0026#39; : \u0026#39;O\u0026#39;); } return ( \u0026lt;\u0026gt; \u0026lt;div className=\u0026#34;status\u0026#34;\u0026gt;{status}\u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;board-row\u0026#34;\u0026gt; \u0026lt;Square value={squares[0]} onSquareClick={() =\u0026gt; handleClick(0)} /\u0026gt; \u0026lt;Square value={squares[1]} onSquareClick={() =\u0026gt; handleClick(1)} /\u0026gt; \u0026lt;Square value={squares[2]} onSquareClick={() =\u0026gt; handleClick(2)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;board-row\u0026#34;\u0026gt; \u0026lt;Square value={squares[3]} onSquareClick={() =\u0026gt; handleClick(3)} /\u0026gt; \u0026lt;Square value={squares[4]} onSquareClick={() =\u0026gt; handleClick(4)} /\u0026gt; \u0026lt;Square value={squares[5]} onSquareClick={() =\u0026gt; handleClick(5)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;board-row\u0026#34;\u0026gt; \u0026lt;Square value={squares[6]} onSquareClick={() =\u0026gt; handleClick(6)} /\u0026gt; \u0026lt;Square value={squares[7]} onSquareClick={() =\u0026gt; handleClick(7)} /\u0026gt; \u0026lt;Square value={squares[8]} onSquareClick={() =\u0026gt; handleClick(8)} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ); } export default function Game() { // 设置棋盘记录状态  const [history, setHistory] = useState([Array(9).fill(null)]); // [null, null, null, null, null, null, null, null, null]  // 第 N 步  const [currentMove, setCurrentMove] = useState(0); // 判断下一个是玩家 X 或者 O  const xIsNext = currentMove % 2 === 0; // 当前步对应的棋盘  const currentSquares = history[currentMove]; function handlePlay(nextSquares) { // 三个点 `...`, 展开语法  // nextHistory 是二维数组, 每一行对应一步执行完后的棋盘  const nextHistory = [...history.slice(0, currentMove + 1), nextSquares]; setHistory(nextHistory); setCurrentMove(nextHistory.length - 1); } // 这里 jumpTo 基本等同于 setCurrentMove, 为什么要这样写?  // 推测 setCurrentMove 没有对外暴露, 待完善  function jumpTo(nextMove) { setCurrentMove(nextMove); } const moves = history.map((squares, move) =\u0026gt; { let description; if (move \u0026gt; 0) { description = \u0026#39;Go to move #\u0026#39; + move; } else { description = \u0026#39;Go to game start\u0026#39;; } return ( \u0026lt;li key={move}\u0026gt; \u0026lt;button onClick={() =\u0026gt; jumpTo(move)}\u0026gt;{description}\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; ); }); return ( \u0026lt;div className=\u0026#34;game\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;game-board\u0026#34;\u0026gt; \u0026lt;Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;game-info\u0026#34;\u0026gt; \u0026lt;ol\u0026gt;{moves}\u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } // 枚举出所有可能的, 一方获胜的情况 function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6], ]; for (let i = 0; i \u0026lt; lines.length; i++) { const [a, b, c] = lines[i]; // a=b=c 且不为 null  if (squares[a] \u0026amp;\u0026amp; squares[a] === squares[b] \u0026amp;\u0026amp; squares[a] === squares[c]) { return squares[a]; } } return null; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u0026lt;!-- 以下是生成的 HTML --\u0026gt; \u0026lt;div class=\u0026#34;game\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;game-board\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;status\u0026#34;\u0026gt;Next player: X\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;board-row\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;board-row\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;board-row\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;square\u0026#34;\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;game-info\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; \u0026lt;button\u0026gt;Go to game start\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;   Tutorial: Tic-Tac-Toe – React\n","date":"2023-06-05T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/react/tic-tac-toe/","title":"Tic Tac Toe"},{"content":"使用hugo建站, 点击代码块中右上角的 Copy按钮时, 发现没有生效\n仔细对比了一下stack主题的config文件以及content文件夹下的markdown源码, 复制代码并不需要额外特殊设置, 于是打开控制台, 发现确实有代码报错, 报错信息如下\nUncaught TypeError: Cannot read properties of undefined (reading 'writeText') at HTMLButtonElement.\u0026lt;anonymous\u0026gt; (main.js:4:429) (匿名) @ main.js:4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let r = document.querySelectorAll(\u0026#34;.article-content div.highlight\u0026#34;) , i = \u0026#34;Copy\u0026#34; , n = \u0026#34;Copied!\u0026#34;; r.forEach(o=\u0026gt;{ let s = document.createElement(\u0026#34;button\u0026#34;); s.innerHTML = i, s.classList.add(\u0026#34;copyCodeButton\u0026#34;), o.appendChild(s); let a = o.querySelector(\u0026#34;code[data-lang]\u0026#34;); !a || s.addEventListener(\u0026#34;click\u0026#34;, ()=\u0026gt;{ navigator.clipboard.writeText(a.textContent).then(()=\u0026gt;{ //此行报错  s.textContent = n, setTimeout(()=\u0026gt;{ s.textContent = i } , 1e3) } ).catch(d=\u0026gt;{ alert(d), console.log(\u0026#34;Something went wrong\u0026#34;, d) } ) } ) } )   代码中可以看到, 使用 navigator.clipboard API 来实现复制\n于是搜索了一下这个 API , 在阮一峰老师的一篇文章 剪贴板操作 Clipboard API 教程 - 阮一峰的网络日志 找到了答案\n 如果navigator.clipboard属性返回undefined，就说明当前浏览器不支持这个 API。 由于用户可能把敏感数据（比如密码）放在剪贴板，允许脚本任意读取会产生安全风险，所以这个 API 的安全限制比较多。\n首先，Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（localhost）允许使用非加密协议。\n其次，调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：clipboard-write（写权限）和clipboard-read（读权限）。\u0026ldquo;写权限\u0026quot;自动授予脚本，而\u0026quot;读权限\u0026quot;必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。\n 由于我是使用hugo生成了页面文件, 然后用nginx搭建静态网站, 在nginx中同时监听了 http 和 https\n访问时直接输入域名, 实际访问的是 http 协议的地址, 无法使用这个API\n在地址栏完整输入了 https:// 开头的协议之后, 果然可以成功复制内容了\n","date":"2023-06-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/hugo/hugo-copy-code/","title":"Hugo Copy Code"},{"content":"Built-in Shortcodes figure Shortcodes - figure | Hugo\nhighlight 用于展示代码片段, 通常情况下 展示代码使用 markdown 语法即可, 是否显示行号, 代码起始行号等可以在配置文件中设置\n 渲染结果如下:\n42{{ range .Pages }} 43 \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; 44{{ end }} ref \u0026amp; relref 渲染如下:\nhugo-image\n第三方 Shortcodes stack quote 1     效果如下: ","date":"2023-06-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/hugo/hugo-shortcodes/","title":"Hugo Shortcodes"},{"content":"apt(Advanced Package Tool) apt 是 Debian 系的Linux发行版默认的软件包管理器, 本文暂不讨论apt 和 apt-get 的关系与区别\napt命令必须以具有sudo权限的用户运行, 以下示例省略前面的sudo\nsearch apt search package_name\nshow apt show package_name 显示有关给定软件包的信息，包括其依赖项、安装、下载大小、软件包可用的来源、软件包内容的描述等\ninstall apt install package1 package2 安装软件包, 多个软件包名使用空格分隔\nupdate \u0026amp; upgrade apt update 从APT存储库中获取最新索引数据\napt upgrade 将已安装的软件包升级到最新版本\napt upgrade package_name 升级单个软件包\nlist apt list --installed 列出已安装的软件包\napt list --upgradeable 获取可升级软件包的列表\nremove \u0026amp; purge remove 和 purge 的区别: remove 保留软件包的配置文件, 而 purge 会卸载软件包并删除配置文件\nPS: 当我们安装了一个软件包, 发现某些设置和默认的设置不一致时, 需要注意是不是之前安装过这个软件, 然后使用remove删除, 重新安装之后使用了之前的配置文件导致的\napt remove package_name\napt purge package_name\nautoremove apt autoremove 用于删除某些(为了满足其他软件包依赖)自动安装的包\n","date":"2023-06-01T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/apt-cheat-sheet/","title":"apt 速查表"},{"content":"1 2 3 4  dt = {\u0026#39;sep\u0026#39;: \u0026#39; # \u0026#39;, \u0026#39;end\u0026#39;: \u0026#39;\\n\\n\u0026#39;} print(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, **dt) # 等价于 print(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, sep=\u0026#39; # \u0026#39;, end=\u0026#39;\\n\\n\u0026#39;)   ","date":"2023-06-01T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python/python-kwargs/","title":"Python 魔法变量"},{"content":"许多软件文档中, 代码示例的部分, 经常会使用 \u0026lsquo;foobar\u0026rsquo;或者 \u0026lsquo;foo\u0026rsquo;, \u0026lsquo;bar\u0026rsquo; 作为变量, 这两个单词具体是什么意思有点困惑, 词典给出的中文翻译都联系不上\ntl;dr:\n结合国情来理解, foo 和 bar 就是课文中的小明和小红, 罗翔刑法案例中的张三, 张宇高数课, 等价无穷小公式中的狗\n以下是维基百科给出的详细解释:\nFoobar - Wikipedia\n 在编程中, 还有许多类似的约定俗成的占位符\n比如 python 中的 单下划线_, 表示某个临时的无关紧要的变量\nxargs命令参数中的 -I {}\nfind命令 -exec 参数后 的 {}\n","date":"2023-05-31T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/foo-bar/","title":"编程文档中的 Foo Bar"},{"content":"大部分编程语言中, 格式化日期的方式都是使用 YYYMMddHHMMSS 类似的字符串, 又或者是 %Y%m 之类的字符串\n而 golang 比较奇特, 日期格式化是使用一个具体的日期常量 2006-01-02 15:04:05 的不同表示方法来设置格式\n 这个日期可以记为 1 月 2 日, 下午 3 点 4 分 5 秒, 06 年 -7 时区\n ","date":"2023-05-30T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/golang/go-time-format-2006-01-02/","title":"golang 日期格式化"},{"content":"VBA(For Excel) Excel 单元格内容格式 单元格里的数据类型系统是根据数据内容确定的, 比如：你将 A 列单元格格式设为保留两位的数值型, 当你在 A1 输入 5 时, 它就显示为 5.00, 如果输入 ABC, 它就不会变成数值型, 而是文本型, 如果将文本改为数字后, 又回到你设置的保留两位小数格式所以单元格设置格式只能对能转换的数据有效(当你设置为文本型后，所有输入字符都能转换为文本，可以理解为文本型才是单元格真正能设置的格式)\n相对地址 \u0026amp; 绝对地址($) 在单元格引用中, $表示 绝对引用, 绝对引用能够在自动填充和复制粘贴时保持引用单元格的绝对位置\n如果C2单元格值为 =A2*B2, 自动填充后, C3单元格值为 =A3*B3\n如果C2单元格值为 =$A$2*B2, 自动填充后, C3单元格值为 =$A$2*B3\n引用单元格   A1 表示法\nRange(\u0026ldquo;A1\u0026rdquo;)\nRange(\u0026ldquo;A1:B5\u0026rdquo;)\nRange(\u0026ldquo;A1:B5,C1:D5\u0026rdquo;)\nRange(\u0026ldquo;A:A\u0026rdquo;)\nRange(\u0026ldquo;1:1\u0026rdquo;)\nRange(\u0026ldquo;A:C\u0026rdquo;)\nRange(\u0026ldquo;1:5\u0026rdquo;)\nRange(\u0026ldquo;1:1,3:3,8:8\u0026rdquo;)\nRange(\u0026ldquo;A:A,C:C,F:F\u0026rdquo;)\n  索引编号(适合用于循环)\nCells(6, 1)\n  快捷表示法\n[A1:B5]\n  相对引用\nOffset(Row, Col)\n  Range 表示连续的区域有两种表达:  Range(\u0026ldquo;起始单元格\u0026rdquo;,\u0026ldquo;结束单元格\u0026rdquo;) Range(\u0026ldquo;起始单元格:结束单元格\u0026rdquo;)  Range 表示非连续的区域: Range(\u0026quot;A1:A2, B3:B4\u0026quot;).Value = 10\n 浮点数比较 浮点数是不精确数据, 不能用等号判断是否相等\nbool isEqual = abs(f1-f2) \u0026lt;= epsilon\nDecimal 类型只能在 Variant 内使用\nDecimal类型无法被直接声明\n先声明一个Variant, 再使用 Cdec()变成Decimal\n","date":"2023-05-30T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/excel/vba-notebook/","title":"VBA 笔记"},{"content":"C# 中可以通过 Diagnostics.Process 类来实现调用外部的可执行文件\n下面是一段调用 PowerPoint 演示幻灯片的脚本:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using System.Diagnostics; namespace awake { class Program { static void Main(string[] args) { Process p = new Process(); // powershell 的命令行工具  p.StartInfo.FileName = \u0026#34;C:\\\\Program Files (x86)\\\\Microsoft Office\\\\Office16\\\\POWERPNT.EXE\u0026#34;; // /S 后面跟着命令的参数  p.StartInfo.Arguments = \u0026#34;/S \\\u0026#34;E:\\\\mail\\\\keep awake.pptx\\\u0026#34;\u0026#34;; p.StartInfo.CreateNoWindow = true; p.StartInfo.UseShellExecute = false; p.Start(); } } }   ","date":"2023-05-29T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/dotnet/csharp-call-command-line/","title":"Csharp 调用外部exe"},{"content":"7z 命令行基本语法为\n1  7z \u0026lt;command\u0026gt; [\u0026lt;switch\u0026gt;...] \u0026lt;base_archive_name\u0026gt; [\u0026lt;arguments\u0026gt;...]   通配符 *.txt: means all files with an extension of \u0026ldquo;.txt\u0026rdquo; ?a*: means all files with a second character of \u0026ldquo;a\u0026rdquo; *1*: means all names that contains character \u0026ldquo;1\u0026rdquo; *.*.*: means all names that contain two at least \u0026ldquo;.\u0026rdquo; characters\ncommands l (List) 列出压缩文件中的所有内容\n1  7z l archive.zip   a (Add) 1 2 3 4 5 6 7 8 9  7z a -tzip archive.zip subdir # -tzip 表示压缩包格式为 zip # -t{archive_type}, 若不指定, 则使用默认格式 7z # 将 文件夹 subdir 及其子文件、子文件夹 添加到压缩文件 archive.zip 7z a -tzip Files.zip *.txt -r # -r (Recurse), 表示递归, 包含子文件夹 # 将当前文件夹及子文件夹下面的所有 .txt 文件添加到压缩包 Files.zip 中 # 生成的压缩包包含目录结构, 但仅限于包含 目标类型文件的子文件夹   e (Extract) 1 2 3 4 5  7z e archive.zip # extracts all files from archive archive.zip to the current directory. 7z e archive.zip -oc:\\soft *.cpp -r # extracts all *.cpp files from archive archive.zip to c:\\soft folder.   x (eXtract with full paths) command 1 2 3 4 5  7z x archive.zip # extracts all files from the archive archive.zip to the current directory. 7z x archive.zip -oc:\\soft *.cpp -r # 提取压缩包`archive.zip`中所有的 `.cpp` 文件到文件夹 c:\\soft 中   命令 e 和 x 解压的区别 使用 x 参数解压, 会保留压缩包内部的文件夹结构, 解压结果和日常使用右键-\u0026gt;解压缩至\u0026hellip;, 结果相同\n使用 e 参数提取文件, 则会将压缩包内部所有层级的文件/文件夹都提取到同一个文件夹中\nExamples 将当前路径下的所有 zip 文件解压到当前路径下, 以压缩包名称命名的文件夹中\n1 2 3 4  # 如果 7z.exe 路径没有加到环境变量中, 需要指定完整路径 \u0026amp;\u0026#34;C:\\Program Files\\7-Zip\\7z.exe\u0026#34; x *.zip -o* # 如果已经加入到环境变量中, 可以直接使用 7z 命令 7z x *.zip -o*    官方文档 - 7-Zip Documentation\n","date":"2023-05-26T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/7z-cli-extract-zip/","title":"7z 命令行使用"},{"content":"规格  TOML 是大小写敏感的 TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档 空白是指制表符(0x09)或空格(0x20) 换行是指 LF(0x0A)或 CRLF(0x0D 0x0A) 使用 # 符号作为注释  键值对 TOML 文档最基本的构成区块是键值对, 键名和键值周围的空白会被忽略\n多次定义同一个key是非法的\n1  key = \u0026#34;value\u0026#34;   点分隔符 1 2 3 4  name = \u0026#34;Orange\u0026#34; physical.color = \u0026#34;orange\u0026#34; physical.shape = \u0026#34;round\u0026#34; site.\u0026#34;google.com\u0026#34; = true # 引号内的点不会作为分隔符   等价于\n1 2 3 4 5 6 7 8 9 10  { \u0026#34;name\u0026#34;: \u0026#34;Orange\u0026#34;, \u0026#34;physical\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;shape\u0026#34;: \u0026#34;round\u0026#34; }, \u0026#34;site\u0026#34;: { \u0026#34;google.com\u0026#34;: true } }   表 表（也被称为哈希表或字典）是键值对的集合 它们由表头定义，连同方括号作为单独的行出现 表头不同于数组，因为数组只有值 缩进会被忽略\n从表头下方, 直至下一个表头或者文件结束, 都是这个表的键值对\n1 2 3 4 5 6 7  [table-1] key1 = \u0026#34;some string\u0026#34; key2 = 123 [table-2] key1 = \u0026#34;another string\u0026#34; key2 = 456   等价于\n1 2 3 4 5 6 7 8 9 10  { \u0026#34;table-1\u0026#34;: { \u0026#34;key1\u0026#34;: \u0026#34;some string\u0026#34;, \u0026#34;key2\u0026#34;: 123 }, \u0026#34;table-2\u0026#34;: { \u0026#34;key1\u0026#34;: \u0026#34;another string\u0026#34;, \u0026#34;key2\u0026#34;: 456 } }   表数组 1 2 3 4 5 6 7 8  [[products]] name = \u0026#34;Hammer\u0026#34; sku = 738594937 [[products]] # 数组里的空表 [[products]] name = \u0026#34;Nail\u0026#34; sku = 284758393 color = \u0026#34;gray\u0026#34;   等价于\n1 2 3 4 5 6 7  { \u0026#34;products\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Hammer\u0026#34;, \u0026#34;sku\u0026#34;: 738594937 }, { }, { \u0026#34;name\u0026#34;: \u0026#34;Nail\u0026#34;, \u0026#34;sku\u0026#34;: 284758393, \u0026#34;color\u0026#34;: \u0026#34;gray\u0026#34; } ] }    TOML to JSON\n","date":"2023-05-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/toml/","title":"TOML 配置文件"},{"content":"之前任职于一家台湾公司, 公司员工电脑默认的默认编码格式使用的是港台地区的 Big5 编码, 俗称 大五码, 且员工没有管理员权限, 不能修改, 而服务器使用的编码是GBK\n由于VBA年代比较久, 使用的还是代码页表示不同语言的字符集(GBK的代码页 936, Big5 的代码页面 950), 没有使用Unicode, 当在员工电脑录制编写的VBA脚本, 保存在xlsm文件中, 需要放到服务器上去执行时, 中文部分会显示乱码\n于是, 编写了下面这段代码来转换xlsm文件中的VBA脚本编码, 主要做了以下事情\n 将xlsm文件中的VBA代码导出为.bas代码文件 转换纯文本代码文件的编码格式(big5改为GBK) 将转换编码之后的代码导入xlsm文件 生成exe后, 可以通过命令行执行, 也可以直接拖动图标将xlsm文件拖到生成的.exe文件上  如果有需求要批量导出xlsm文件中的脚本代码, 下面的代码修改一下也可以实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  using System; using System.IO; using System.Text; using Excel = Microsoft.Office.Interop.Excel; using Microsoft.Vbe.Interop; namespace XLSM_Big52GBK_Converter { class Program{ static void ConvertEncoding(string sourcePath, string destPath){ string content; // 以 Big5 编码读取文本内容  content = File.ReadAllText(sourcePath, Encoding.GetEncoding(950)); // 以 GBK 编码写入新文本文件  File.WriteAllText(destPath, content, Encoding.GetEncoding(936)); } static void End(){ Console.WriteLine(\u0026#34;OK\u0026#34;); Console.WriteLine(\u0026#34;Press Any Key to Close\u0026#34;); Console.ReadKey(); } static void Main(string[] args){ Excel.Application app = new Excel.Application(); app.DisplayAlerts = false; string oFilename, nFilename, dir, oBas, nBas; if (args.Length == 0){ // 因为命令行窗口也是使用的big5代码页, 所以此处输出内容需要使用 繁体字  Console.WriteLine(\u0026#34; 輸入xlsm文件的完整路徑:\u0026#34;); nFilename = Console.ReadLine(); } else{ nFilename = args[0]; } nFilename = nFilename.Trim(\u0026#39;\\\u0026#34;\u0026#39;); if (!nFilename.ToLower().EndsWith(\u0026#34;.xlsm\u0026#34;)){ return; } Console.WriteLine(\u0026#34;converting...\u0026#34;); dir = Path.GetDirectoryName(nFilename); oFilename = Path.Combine(dir, Path.GetFileNameWithoutExtension(nFilename) + \u0026#34;_old.xlsm\u0026#34;); oBas = Path.Combine(dir, \u0026#34;old.bas\u0026#34;); nBas = Path.Combine(dir, \u0026#34;new.bas\u0026#34;); File.Copy(nFilename, oFilename, true); Excel.Workbook oWb = app.Workbooks.Open(oFilename); Excel.Workbook nWb = app.Workbooks.Open(nFilename); foreach (VBComponent cp in nWb.VBProject.VBComponents){ if (cp.Type == vbext_ComponentType.vbext_ct_StdModule){ int n = cp.CodeModule.CountOfLines; cp.CodeModule.DeleteLines(1, n); } } foreach (VBComponent comp in oWb.VBProject.VBComponents){ if (comp.Type == vbext_ComponentType.vbext_ct_StdModule){ comp.Export(oBas); // 转换文本编码  ConvertEncoding(oBas, nBas); // 导入转换编码后的 bas 文件  nWb.VBProject.VBComponents.Item(comp.Name).CodeModule.AddFromFile(nBas); } } oWb.Close(false); nWb.Close(true); End(); } } }    VBA 实现Excel单元格(或者Word)中的繁简转换, 可以使用以下两种方法\n 调用 EXCEL 的 TCSCConv.SharedAddin, 对sheet内容进行繁简转换 调用系统API LCMapString 对String进行繁简转换  受限于本机非Unicode程式的编码格式, 可能会出现VBA本身就无法识别出简体中文的情况（当本机编码为big5时）\n1 2  Private Declare Function LCMapString Lib \u0026#34;kernel32\u0026#34; Alias \u0026#34;LCMapStringA\u0026#34; (ByVal Locale As Long, ByVal dwMapFlags As Long, ByVal lpSrcStr As String, ByVal cchSrc As Long, ByVal lpDestStr As String, ByVal cchDest As Long) As Long Private Declare Function lstrlen Lib \u0026#34;kernel32\u0026#34; Alias \u0026#34;lstrlenA\u0026#34; (ByVal lpString As String) As Long   ","date":"2023-05-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/dotnet/convert-xlsm-macro-encoding/","title":"更改xlsm文件中的宏脚本编码"},{"content":"Nginx 反向代理的配置块内容通常如下:\n1 2 3  location [ = | ~ | ~* | ^~ ] uri { proxy_pass URL; }   proxy_pass 后面的 URL, 如果带 /, 表示绝对路径, 如果不带 /, 表示相对路径\n通常 URL = host[:port][path](中括号内的内容表示可选)\n如 https://www.example.com:8080/,\nhttps:// 是协议, www.example.com 是 host, 80 是 port, / 是 path\n  proxy_pass 后面的 URL 不包含 path 时, 如 https://www.example.com:8080\ntarget_url = URL + uri\n  proxy_pass 后面的 URL 包含 path 时, (/也算)(如 https://www.example.com/)\ntarget_url = URL.replace(uri, path)\n   以下这篇文章写得非常通俗易懂, 并且举了很详细的例子加以说明\nproxy_pass url 反向代理的坑 | Nginx 入门教程\n","date":"2023-05-24T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/nginx-proxy-pass/","title":"Nginx 反向代理中的路径问题"},{"content":"使用 ssh 客户端远程连接到服务器时, 默认情况下, 一段时间不操作, 没有向服务器发送指令, 就自动断开了连接, 需要重新登录\n使用过的客户端中, xshell 默认情况下是会自动发送心跳来保持连接, 其他的一些如 mobaxterm, windterm, windows terminal自带的ssh, 时间久没有操作都是会断开连接的, 需要手动设置, 以下是手动设置的方法\n 命令行参数设置  如果是在终端中使用ssh命令连接远程机器, 如在Windows Terminal中, 可以通过添加以下参数来设置每隔60秒向Server端发送一个空包以保持连接\n1  ssh -o ServerAliveInterval=60 root@127.0.0.1   使用以上参数只会对本次连接会话有效, 如果需要每次都自动保持连接, 可以使用下面的方法\n客户端.ssh/config文件设置  ~/.ssh/config 文件中添加ServerAliveInterval 60\nHost xxx HostName 127.0.0.1 User root ServerAliveInterval 60 ","date":"2023-05-19T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/ssh-timeout/","title":"关于SSH长时间无操作自动断开"},{"content":"测试 hugo 主题 stack 中的 bilibili 视频 shortcode\n\r\r","date":"2023-05-13T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/bilibili-video-test/","title":"bilibili 视频 shortcode 测试"},{"content":"问题 初次尝试使用 Hugo 写一篇带图片的文章时, 遇到如下问题:\n文件放在路径 /static/image/ 下, markdown 文件中的路径是![](/image/image1.png)\n使用命令 hugo server 生成站点时, 可以在生成的页面中看到\n  但是发布到 Github Pages 或者 Nginx 生成静态网站时, 不会显示图片\n文件放在路径 /static/image/ 只是 hugo 的约定\n解决办法 新建文章时候, 直接新建 文件夹, 内容写在 index.md 中, 图片文件放在同名文件夹下面\ncontent └── post └── my-first-post ├── index.md ├── image1.png └── test.png  ![Alt text](test.png)\n渲染如下:\n 这样的好处是, 不论是使用 hugo server 生成静态页面文件还是发布到 Github Pages, 或是使用 markdown 编辑器的预览功能, 都可以渲染图片\n","date":"2023-05-13T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/hugo/hugo-image/","title":"Hugo 文章中的图片显示问题"},{"content":"MIME 类型 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。\nMIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。\n浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。\n语法 MIME 类型通用结构：\n type/subtype\n MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 / 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。\nMIME类型对大小写不敏感，但是传统写法都是小写。\n两种主要的 MIME 类型在默认类型中扮演了重要的角色：\n text/plain 表示文本文件的默认值。 application/octet-stream 表示所有其他情况的默认值。   摘自 MIME 类型 | 菜鸟教程\n","date":"2023-04-28T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/mime/","title":"MIME"},{"content":"介绍 rep - print lines that match patterns\n语法 grep searches for PATTERNS in each FILE. PATTERNS is one or more patterns separated by newline characters, and grep prints each line that matches a pattern. Typically PATTERNS should be quoted when grep is used in a shell command.\nA FILE of “-” stands for standard input. If no FILE is given,recursive searches examine the working directory and nonrecursive searches read standard input.\n1 2 3 4  grep [options...] [pattern] [file...] # option参数和file参数, 可以是0个或者多个, pattern 可以是一或多个 # pattern 支持正则表达式 # file 支持 通配符   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  # -i 忽略大小写 grep -i ^DA demo.txt # Search only for the full word, -w # 仅匹配整个单词, 如下面的例子, \u0026#34;off\u0026#34; 不会被匹配到 grep -w \u0026#34;of\u0026#34; demo.txt # Display 3 lines after matching string, -A grep -A 3 \u0026#39;Exception\u0026#39; error.log # Display 4 lines before matching string, -B grep -B 4 \u0026#39;Exception\u0026#39; error.log # Display 5 lines around matching string, -C grep -C 5 \u0026#39;Exception\u0026#39; error.log # Recursive search (within subdirs), -r # -r 递归 grep -r \u0026#39;quickref.me\u0026#39; /var/log/nginx/ # -v 反向查找, 只打印不匹配的行 grep -v \u0026#39;warning\u0026#39; /var/log/syslog # Use regex (lines starting with \u0026#39;al\u0026#39;), -e # 正则表达式 grep -e \u0026#39;^al\u0026#39; filename # Extended regex (lines containing jason or jackson), -E grep -E \u0026#39;ja(s|cks)on\u0026#39; filename # -c 打印匹配的行数 grep -c \u0026#39;error\u0026#39; /var/log/syslog # -l 打印匹配的文件名 grep -l \u0026#39;robot\u0026#39; /var/log/* # Only show the matching part of the string, -o grep -o search_string filename # -n 显示匹配的行号 grep -n \u0026#34;go\u0026#34; demo.txt # print the file containing the query including thos within subdirs grep -r ^David ~/some_dir/* # print the name of the file(s) which matches the query # --file-with-matches grep -l ^David ~/some_dir/* # -L --files-without-match #  grep -rL \u0026#39;date = \u0026#39; ./content/*/*.md    Grep Command Cheat Sheet \u0026amp; Quick Reference\nshell脚本——grep详解 - 知乎\n","date":"2023-04-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/grep-cheat-sheet/","title":"Grep 速查表"},{"content":"1 2 3  $root_path = \u0026#34;D:\\folder_name\u0026#34; $log_file = \u0026#34;D:\\log_file.txt\u0026#34; ls $root_path -recurse | get-filehash | group -property hash | where { $_.count -gt 1 } | % { $_.group } | epcsv $log_file   ","date":"2023-04-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-remove-duplicate-files/","title":"Powershell 删除重复文件脚本"},{"content":"Usage  search for files in a directory hierarchy\n 1  find [path...] [options] [expression]   An expression is composed of a sequence of things:\n Tests Actions Global options Positional options Operators   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # Wildcard find . -name \u0026#34;*.txt\u0026#34; find . -name \u0026#34;2020*.csv\u0026#34; find . -name \u0026#34;json_*\u0026#34; # regex # TODO # directory find . -type d # file find . -type f ## Size # Find all bigger than 10MB files, 查找大于10M的文件 find . -size +10M # Find all smaller than 10MB files, 查找小于10M的文件 find . -size -10M # Find Size between 100MB and 1GB, 查找大于100M且小于1G的文件 find . -size +100M -size -1G   multiple dirs \u0026amp; filenames 1 2 3 4  # Find files with multiple dirs find /opt /usr /var -name foo.scala -type f # Find files with .sh and .txt extensions find . -type f \\( -name \u0026#34;*.sh\u0026#34; -o -name \u0026#34;*.txt\u0026#34; \\)   Find and \u0026hellip; find and replace 1 2 3 4 5 6 7  # Find all files and modify the content const to let # s表示substitute, 替换操作 # g表示global, 全局替换 find ./ -type f -exec sed -i \u0026#39;s/const/let/g\u0026#39; {} \\; # Find readable and writable files and modify the content old to new find ./ -type f -readable -writable -exec sed -i \u0026#34;s/old/new/g\u0026#34; {} \\;   find and move 1 2 3  # Find and move it to a specific directory (/tmp/music) # {} 表示find找到的每一个文件名(相当于PowerShell中的 $_) find . -name \u0026#39;*.mp3\u0026#39; -exec mv {} /tmp/music \\;   Find and concatenate 1 2 3 4  # Merge all csv files in the download directory into merged.csv find download -type f -iname \u0026#39;*.csv\u0026#39; | xargs cat \u0026gt; merged.csv # Merge all sorted csv files in the download directory into merged.csv find download -type f -iname \u0026#39;*.csv\u0026#39; | sort | xargs cat \u0026gt; merged.csv   find and delete 1 2 3 4 5 6  # Find all file names ending with .pdf, then remove them. find -name \\*.pdf | xargs rm # The above, however, is better-written without xargs: find -name \\*.pdf -exec rm {} \\+ # Although it\u0026#39;s best to use find\u0026#39;s own functionality, in this situation. find -name \\*.pdf -delete    find\nFind Command Cheat Sheet \u0026amp; Quick Reference\n","date":"2023-04-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/find-cheat-sheet/","title":"Find 速查表"},{"content":"1 2 3 4 5 6 7 8  # 新建会话 tmux new -s session_name # Attach to last session tmux a # Attach to a session with the name mysession tmux a -t mysession   常用快捷键 将当前会话与窗口分离\nCtrl+b d\n列出当前所有会话(此快捷键需要在tmux会话内执行)\nCtrl+b s\n划分左右两个窗格\nCtrl+b %\n划分上下两个窗格\nCtrl+b \u0026quot;\n关闭当前窗格\nCtrl+b x\n调整窗格大小 Ctrl+b Ctrl+方向键\ncopy mode 进入窗口之后不支持上下翻页, 使用以下快捷键进入 copy mode\nCtrl+b [\n按 q 退出\n参考 Tmux Cheat Sheet \u0026amp; Quick Reference\nTips tmux划分窗格后, 只能通过 Ctrl+b + 方向键 在不同的窗格之间切换光标焦点, 并且在tmux窗口中, 需要进入copy mode才能上下翻页, 所以个人在日常使用中, 并不会经常使用tmux的拆分窗格等功能, 更多的是使用客户端软件(如 xshell, Windows Terminal)自带的拆分窗口功能, 一个账号同时登录多个会话(不执行影响其他会话的命令), 切换窗口和翻页更方便\n","date":"2023-04-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/tmux/","title":"Tmux 速查表"},{"content":"Windows11 系统的笔记本电脑在使用电源时, 会出现偶尔屏幕变暗又恢复的情况\n解决方法:\n打开 设置 \u0026gt; 系统 \u0026gt; 屏幕, 点击亮度调节 右侧下拉选项, 取消勾选 通过优化显示的内容和亮度降低电池能耗\n","date":"2023-04-12T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/win11-brightness/","title":"Win11 笔记本亮度调节"},{"content":"浏览器 WPS Office 及及大部分支持横向滚动的桌面端软件, 支持 Shift + 鼠标滚轮 实现横向滚动\nMicrosoft Office 的 Excel 横向滚动的方式是 Ctrl + Shift + 鼠标滚轮\n","date":"2023-04-11T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/microsoft-excel-scroll/","title":"Microsoft Excel 横向滚动"},{"content":"简介 tldr(Too Long; Didn\u0026rsquo;t Read) 是一个开源的命令行工具，提供简洁的命令行使用文档\ntldr 提供了 web端 tldr InBrowser.App, nodejs 和 python 客户端以及 PDF版本\n安装 1 2 3 4 5 6  # nodejs npm install tldr # python pip3 install tldr   使用 tldr sed sed Edit text in a scriptable manner. See also: `awk`, `ed`. More information: https://www.gnu.org/software/sed/manual/sed.html. - Replace all `apple` (basic regex) occurrences with `mango` (basic regex) in all input lines and print the result to `stdout`: command | sed 's/apple/mango/g' - Execute a specific script [f]ile and print the result to `stdout`: command | sed -f path/to/script.sed - Replace all `apple` (extended regex) occurrences with `APPLE` (extended regex) in all input lines and print the result to `stdout`: command | sed -E 's/(apple)/\\U\\1/g' - Print just a first line to `stdout`: command | sed -n '1p' - Replace all `apple` (basic regex) occurrences with `mango` (basic regex) in a specific file and overwrite the original file in place: sed -i 's/apple/mango/g' path/to/file ","date":"2023-04-10T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/linux/tldr-cheat-sheet/","title":"tldr - 更加简洁的帮助文档"},{"content":"GPT-Mirror\n","date":"2023-04-09T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/gpt_mirror/","title":"Gpt_Mirror"},{"content":"\u0026ldquo;Everything\u0026rdquo; 是什么？ \u0026ldquo;Everything\u0026rdquo; 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。\n如何在运行 \u0026ldquo;Everything\u0026rdquo; 时屏蔽 UAC 警告？ \u0026ldquo;Everything\u0026rdquo; 需要管理员权限以便低级别读取 NTFS 分卷来 NTFS 索引。\nUAC 警告可以通过以标准用户运行 \u0026ldquo;Everything\u0026rdquo; 和安装 \u0026ldquo;Everything\u0026rdquo; 服务或不使用 NTFS 索引来避免。\n以标准用户运行 \u0026ldquo;Everything\u0026rdquo; 和安装 \u0026ldquo;Everything\u0026rdquo; 服务：\n在 \u0026ldquo;Everything\u0026rdquo; 中，打开工具菜单，点击选项。\n  点击常规页面。\n  检查 Everything 服务。\n  取消以管理员方式运行。\n  点击确定。\n  退出 \u0026ldquo;Everything\u0026rdquo; (右键 Everything 托盘图标并点击退出)。\n  重启 Everything。\n  搜索 \u0026ldquo;Everything\u0026rdquo; 能否搜索文件内容？ 可以，\u0026ldquo;Everything\u0026rdquo; 可以通过搜索函数 content: 来搜索文件内容。\n文件内容未被索引时，搜索内容将会很慢。\n如何使用通配符？ 搜索关键词中使用通配符 * 将会匹配任意数量的任意字符。\n例如，搜索以 e 开头并以 g 结尾的文件和文件夹：e*g\n搜索关键词中使用通配符 ? 将会匹配任一字符。\n例如，搜索含有两个字符扩展名的文件：*.??\n如何搜索文件类型？ 搜索文件类型，请在搜索框输入扩展名，\n例如，搜索 mp3 文件，输入 *.mp3 即可。\n搜索多个文件类型，请使用 | 分隔，\n例如：*.bmp|*.jpg 将会搜索 bmp 或 jpg 类型文件。\n","date":"2023-04-03T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/everything-search-tool/","title":"Everything Search Tool"},{"content":"Get-History PowerShell 的 Get-History 命令只显示当前会话的历史命令\n关闭当前窗口再打开一个新的PowerShell窗口时, 先前窗口中输入的历史命令无法使用 Get-History 获取到\nPowerShell 没有类似 Linux bash 下的 history 一样, 直接查看所有会话的历史命令的 Cmdlet\n但是和 bash 一样, PowerShell 将所有会话的命令历史记录存储在文本文件中\n这个文件的路径可以通过命令 (Get-PSReadlineOption).HistorySavePath 获取到\nGet-PSReadlineOption Get-PSReadlineOption 命令 包含在 PSReadLine 模块下, 该模块需要 PowerShell 5.1 或更高的版本\n可以通过以下命令来实现查看所有命令历史记录\n1  Get-Content (Get-PSReadlineOption).HistorySavePath    Tips: 如果历史命令中包含中文等非ASCII字符, 需要使用对应的编码读取该文本文件, 否则会显示乱码\n PowerShell 编码 PowerShell 5.1 中 Get-Content 命令的 -Encoding 参数默认是 Default\nDefault 使用与系统的活动代码页相对应的编码 (通常为 ANSI)\n而在 PowerShell 7.2 中, Get-Content 命令的 -Encoding 参数默认是 utf8NoBOM\nutf8NoBOM：以 UTF-8 格式编码，不带字节顺序标记 (BOM)\n","date":"2023-04-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-history/","title":"PowerShell 查看历史命令"},{"content":"简短说明 介绍如何创建和使用 PowerShell 配置文件\n长说明 PowerShell 配置文件是在 PowerShell 启动时运行的脚本。 可以使用配置文件作为启动脚本来自定义环境。 可以添加命令、别名、函数、变量、模块、PowerShell 驱动器等。 还可以将其他特定于会话的元素添加到配置文件中，使其在每个会话中可用，而无需导入或重新创建它们。 PowerShell 支持用户和主机程序的多个配置文件。 但是，它不会为你创建配置文件。\n$PROFILE 变量 变量 $PROFILE 存储 当前用户，当前主机 配置文件 的路径。\n其他配置文件保存在 变量的注释属性中, 可通过以下命令查看对应类型配置文件的路径\n1  $PROFILE | Get-Member -Type NoteProperty   创建、编辑配置文件 1  notepad $PROFILE   如果配置文件首次设置后, 打开 PowerShell 时显示\n无法加载文件 C:\\Users\\Ma\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1，因为在此系统上禁止运行脚本。\n需要以管理员身份运行以下脚本, 修改执行策略以允许加载配置文件\n1  Set-ExecutionPolicy RemoteSigned   使用配置文件 在 PowerShell 中创建的许多项和运行的大多数命令仅影响当前会话。 结束会话时，将删除这些项。\n特定于会话的命令和项包括添加到会话的 PowerShell 变量、环境变量、别名、函数、命令和 PowerShell 模块。\n若要保存这些项并使其在所有将来的会话中可用，请将它们添加到 PowerShell 配置文件。\n配置文件的另一个常见用途是保存常用函数、别名和变量。 将项目保存在配置文件中时，可以在任何适用的会话中使用它们，而无需重新创建它们。\n导入第三方库 Terminal-Icons 美化终端\n1  Import-Module Terminal-Icons   保存常用函数, 如 将 history 设置为查看所有历史命令, 而非仅仅当前会话的历史命令\n1 2 3 4 5 6 7  # 删除原有的别名 history # PowerShell 5.1版本需使用 Remove-Item 删除 # 更高版本的 PowerShell 可直接使用 Remove-Alias 命令 Remove-Item -Path Alias:history function history{ Get-Content (Get-PSReadlineOption).HistorySavePath -Encoding utf8 }    关于配置文件 - PowerShell | Microsoft Learn\n","date":"2023-04-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-profile/","title":"PowerShell 配置文件"},{"content":"多光标操作     ====     Ctrl+I 选中当前行   Shift+Alt+I 将光标插入所选每行的末尾   Ctrl+Shift+L 选择所有与所选中内容相同的内容   Ctrl+F2 选择所有与所选中词汇相同的内容    编辑器控制     ====     Ctrl+\\ 拆分编辑器为多组   Ctrl+ 1 / 2 / 3 切换窗口焦点至某一组    文件管理     ====     Ctrl+K P 复制当前文件路径   Ctrl+K R 打开当前文件所在文件夹    显示     ====     Shift+Alt+0 切换编辑器布局(水平/垂直)   Ctrl+Shift+F 显示搜索界面   Ctrl+Shift+X 显示插件管理界面   Ctrl+K V 预览 Markdown 文件（侧边）   Ctrl+K Z 禅模式（连按两次 Esc 退出）    语言操作     ====     Ctrl+K Ctrl+X 移除行尾空白字符    基础编辑     ====     Ctrl+Shift+K 删除行   Ctrl+Enter 在当前行下方插入新行   Ctrl+Shift+Enter 在当前行上方插入新行   Shift+Alt+A 切换块注释   Alt+Z 切换自动换行   Ctrl+K Ctrl+[ 折叠当前所有子代码块   Ctrl+K Ctrl+] 展开当前所有子代码块     写文章时经常遇到一些英文名词以及缩写, 需要频繁切换输入法中英文以及大小写, 非常不方便, vscode 自带的命令转换选中内容的功能\n具体操作方法: 先选中一段文字内容, 快捷键 control shift + P 唤起命令面板, 输入 Transform\n有小写, 连字符, 下划线, 驼峰等转换风格\n","date":"2023-04-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/others/vscode-keys/","title":"VScode 快捷键"},{"content":"Bookmarklet 是什么 A bookmarklet is a bookmark stored in a web browser that contains JavaScript commands that add new features to the browser. They are stored as the URL of a bookmark in a web browser or as a hyperlink on a web page. Bookmarklets are usually small snippets of JavaScript executed when user clicks on them. When clicked, bookmarklets can perform a wide variety of operations, such as running a search query from selected text or extracting data from a table.\nBookmarklet 可以做什么  浏览器的自动填充功能在部分网站的登录页面不会生效, 点击输入框也不会显示下拉历史记录, 可以使用bookmarklet实现自动输入填充信息登录  1  javascript:(function(){document.querySelector(\u0026#39;#uCode\u0026#39;).value=\u0026#39;username\u0026#39;;document.querySelector(\u0026#39;#pW\u0026#39;).value=\u0026#39;password\u0026#39;;document.querySelector(\u0026#39;#login_btn%20%3E%20button.login\u0026#39;).click();})();    写文章时候, 经常会放上一些摘抄的原网址的标题和链接, 使用下面的bookmarklet可以快速获取文章标题和链接  1  alert(`[${document.title}](${document.URL})`)    上一条改良一下, 直接将markdown格式的链接复制到剪贴板, 免去手动复制  1  navigator.clipboard.writeText(`[${document.title}](${document.URL})`)    再优化一点, 复制成功之后加一个效果(网页标题短暂跳成\u0026quot;Copied!\u0026ldquo;之后又恢复)  1  navigator.clipboard.writeText(`[${document.title}](${document.URL})`);var tt = document.title;document.title=\u0026#34;Copied!\u0026#34;;setTimeout(()=\u0026gt;{document.title=tt}, 1e3)   如何编写 bookmarklet 你只需要编写常规的JavaScript, 网络上有很多在线转换工具, 帮助将常规的js代码生成bookmarklet, 比如:\nBookmarklet Maker\n引用 Bookmarklet - Wikipedia\n阮一峰的 Bookmarklet编写指南\n","date":"2023-03-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/javascript/bookmarklet/","title":"Bookmarklet"},{"content":"题目001: 在Python中如何实现单例模式。  点评：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对Python语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。\n 方法一：使用装饰器实现单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from functools import wraps def singleton(cls): \u0026#34;\u0026#34;\u0026#34;单例类装饰器\u0026#34;\u0026#34;\u0026#34; instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President: pass    扩展：装饰器是Python中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的wrapper函数）通常都会用functools模块中的wraps再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个__wrapped__属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用President = President.__wrapped__来取消对President类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在Python中可以使用threading模块的RLock对象来提供锁，可以使用锁对象的acquire和release方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的with上下文语法来进行隐式的加锁和解锁操作。\n 方法二：使用元类实现单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class SingletonMeta(type): \u0026#34;\u0026#34;\u0026#34;自定义单例元类\u0026#34;\u0026#34;\u0026#34; def __init__(cls, *args, **kwargs): cls.__instance = None super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): pass    扩展：Python是面向对象的编程语言，在面向对象的世界中，一切皆为对象。对象是通过类来创建的，而类本身也是对象，类这样的对象是通过元类来创建的。我们在定义类时，如果没有给一个类指定父类，那么默认的父类是object，如果没有给一个类指定元类，那么默认的元类是type。通过自定义的元类，我们可以改变一个类默认的行为，就如同上面的代码中，我们通过元类的__call__魔术方法，改变了President类的构造器那样。\n  补充：关于单例模式，在面试中还有可能被问到它的应用场景。通常一个对象的状态是被其他对象共享的，就可以将其设计为单例，例如项目中使用的数据库连接池对象和配置对象通常都是单例，这样才能保证所有地方获取到的数据库连接和配置信息是完全一致的；而且由于对象只有唯一的实例，因此从根本上避免了重复创建对象造成的时间和空间上的开销，也避免了对资源的多重占用。再举个例子，项目中的日志操作通常也会使用单例模式，这是因为共享的日志文件一直处于打开状态，只能有一个实例去操作它，否则在写入日志的时候会产生混乱。\n 题目002：不使用中间变量，交换两个变量a和b的值。  点评：典型的送人头的题目，通常交换两个变量需要借助一个中间变量，如果不允许使用中间变量，在其他编程语言中可以使用异或运算的方式来实现交换两个变量的值，但是Python中有更为简单明了的做法。\n 方法一：\n1 2 3  a = a ^ b b = a ^ b a = a ^ b   方法二：\n1  a, b = b, a    扩展：需要注意，a, b = b, a这种做法其实并不是元组解包，虽然很多人都这样认为。Python字节码指令中有ROT_TWO指令来支持这个操作，类似的还有ROT_THREE，对于3个以上的元素，如a, b, c, d = b, c, d, a，才会用到创建元组和元组解包。想知道你的代码对应的字节码指令，可以使用Python标准库中dis模块的dis函数来反汇编你的Python代码。\n 题目003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。  点评：这个题目在初中级Python岗位面试的时候经常出现，题目源于《Python Cookbook》这本书第一章的第10个问题，有很多面试题其实都是这本书上的原题，所以建议大家有时间好好研读一下这本书。\n 1 2 3 4 5 6 7 8  def dedup(items): no_dup_items = [] seen = set() for item in items: if item not in seen: no_dup_items.append(item) seen.add(item) return no_dup_items   如果愿意也可以把上面的函数改造成一个生成器，代码如下所示。\n1 2 3 4 5 6  def dedup(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)    扩展：由于Python中的集合底层使用哈希存储，所以集合的in和not in成员运算在性能上远远优于列表，所以上面的代码我们使用了集合来保存已经出现过的元素。集合中的元素必须是hashable对象，因此上面的代码在列表元素不是hashable对象时会失效，要解决这个问题可以给函数增加一个参数，该参数可以设计为返回哈希码或hashable对象的函数。\n 题目004：假设你使用的是官方的CPython，说出下面代码的运行结果。  点评：下面的程序对实际开发并没有什么意义，但却是CPython中的一个大坑，这道题旨在考察面试者对官方的Python解释器到底了解到什么程度。\n 1 2 3 4 5 6 7 8 9 10 11  a, b, c, d = 1, 1, 1000, 1000 print(a is b, c is d) def foo(): e = 1000 f = 1000 print(e is f, e is d) g = 1 print(g is a) foo()   运行结果：\nTrue False True False True 上面代码中a is b的结果是True但c is d的结果是False，这一点的确让人费解。CPython解释器出于性能优化的考虑，把频繁使用的整数对象用一个叫small_ints的对象池缓存起来造成的。small_ints缓存的整数值被设定为[-5, 256]这个区间，也就是说，在任何引用这些整数的地方，都不需要重新创建int对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。\nCPython底层为了进一步提升性能还做了另一个设定，对于同一个代码块中值不在small_ints缓存范围内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的int对象。需要大家注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点大家可以自行证明。\n 扩展：如果你用PyPy（另一种Python解释器实现，支持JIT，对CPython的缺点进行了改良，在性能上优于CPython，但对三方库的支持略差）来运行上面的代码，你会发现所有的输出都是True。\n 题目005：Lambda函数是什么，举例说明的它的应用场景。  点评：这个题目主要想考察的是Lambda函数的应用场景，潜台词是问你在项目中有没有使用过Lambda函数，具体在什么场景下会用到Lambda函数，借此来判断你写代码的能力。因为Lambda函数通常用在高阶函数中，主要的作用是通过向函数传入函数或让函数返回函数最终实现代码的解耦合。\n Lambda函数也叫匿名函数，它是功能简单用一行代码就能实现的小型函数。Python中的Lambda函数只能写一个表达式，这个表达式的执行结果就是函数的返回值，不用写return关键字。Lambda函数因为没有名字，所以也不会跟其他函数发生命名冲突的问题。\n 扩展：面试的时候有可能还会考你用Lambda函数来实现一些功能，也就是用一行代码来实现题目要求的功能，例如：用一行代码实现求阶乘的函数，用一行代码实现求最大公约数的函数等。\n      fac = lambda x: import(\u0026lsquo;functools\u0026rsquo;).reduce(int.mul, range(1, x + 1), 1) gcd = lambda x, y: y % x and gcd(y % x, x) or x\n Lambda函数其实最为主要的用途是把一个函数传入另一个高阶函数（如Python内置的`filter`、`map`等）中来为函数做解耦合，增强函数的灵活性和通用性。下面的例子通过使用`filter`和`map`函数，实现了从列表中筛选出奇数并求平方构成新列表的操作，因为用到了高阶函数，过滤和映射数据的规则都是函数的调用者通过另外一个函数传入的，因此这`filter`和`map`函数没有跟特定的过滤和映射数据的规则耦合在一起。 ```python items = [12, 5, 7, 10, 8, 19] items = list(map(lambda x: x ** 2, filter(lambda x: x % 2, items))) print(items) # [25, 49, 361]  扩展：用列表的生成式来实现上面的代码会更加简单明了，代码如下所示。\n      items = [12, 5, 7, 10, 8, 19] items = [x ** 2 for x in items if x % 2] print(items) # [25, 49, 361]\n ## 题目006：说说Python中的浅拷贝和深拷贝。 \u0026gt; **点评**：这个题目本身出现的频率非常高，但是就题论题而言没有什么技术含量。对于这种面试题，在**回答的时候一定要让你的答案能够超出面试官的预期**，这样才能**获得更好的印象分**。所以回答这个题目的要点不仅仅是能够说出浅拷贝和深拷贝的区别，深拷贝的时候可能遇到的两大问题，还要说出Python标准库对浅拷贝和深拷贝的支持，然后可以说说列表、字典如何实现拷贝操作以及如何通过序列化和反序列的方式实现深拷贝，最后还可以提到设计模式中的原型模式以及它在项目中的应用。 浅拷贝通常只复制对象本身，而深拷贝不仅会复制对象，还会递归的复制对象所关联的对象。深拷贝可能会遇到两个问题：一是一个对象如果直接或间接的引用了自身，会导致无休止的递归拷贝；二是深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。Python通过`copy`模块中的`copy`和`deepcopy`函数来实现浅拷贝和深拷贝操作，其中`deepcopy`可以通过`memo`字典来保存已经拷贝过的对象，从而避免刚才所说的自引用递归问题；此外，可以通过`copyreg`模块的`pickle`函数来定制指定类型对象的拷贝行为。 `deepcopy`函数的本质其实就是对象的一次序列化和一次返回序列化，面试题中还考过用自定义函数实现对象的深拷贝操作，显然我们可以使用`pickle`模块的`dumps`和`loads`来做到，代码如下所示。 ```python import pickle my_deep_copy = lambda obj: pickle.loads(pickle.dumps(obj)) 列表的切片操作[:]相当于实现了列表对象的浅拷贝，而字典的copy方法可以实现字典对象的浅拷贝。对象拷贝其实是更为快捷的创建对象的方式。在Python中，通过构造器创建对象属于两阶段构造，首先是分配内存空间，然后是初始化。在创建对象时，我们也可以基于“原型”对象来创建新对象，通过对原型对象的拷贝（复制内存）就完成了对象的创建和初始化，这种做法更加高效，这也就是设计模式中的原型模式。在Python中，我们可以通过元类的方式来实现原型模式，代码如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import copy class PrototypeMeta(type): \u0026#34;\u0026#34;\u0026#34;实现原型模式的元类\u0026#34;\u0026#34;\u0026#34; def __init__(cls, *args, **kwargs): super().__init__(*args, **kwargs) # 为对象绑定clone方法来实现对象拷贝 cls.clone = lambda self, is_deep=True: \\ copy.deepcopy(self) if is_deep else copy.copy(self) class Person(metaclass=PrototypeMeta): pass p1 = Person() p2 = p1.clone() # 深拷贝 p3 = p1.clone(is_deep=False) # 浅拷贝   题目007：Python是如何实现内存管理的？  点评：当面试官问到这个问题的时候，一个展示自己的机会就摆在面前了。你要先反问面试官：“你说的是官方的CPython解释器吗？”。这个反问可以展示出你了解过Python解释器的不同的实现版本，而且你也知道面试官想问的是CPython。当然，很多面试官对不同的Python解释器底层实现到底有什么差别也没有概念。所以，千万不要觉得面试官一定比你强，怀揣着这份自信可以让你更好的完成面试。\n Python提供了自动化的内存管理，也就是说内存空间的分配与释放都是由Python解释器在运行时自动进行的，自动管理内存功能极大的减轻程序员的工作负担，也能够帮助程序员在一定程度上解决内存泄露的问题。以CPython解释器为例，它的内存管理有三个关键点：引用计数、标记清理、分代收集。\n引用计数：对于CPython解释器来说，Python中的每一个对象其实就是PyObject结构体，它的内部有一个名为ob_refcnt 的引用计数器成员变量。程序在运行的过程中ob_refcnt的值会被更新并藉此来反映引用有多少个变量引用到该对象。当对象的引用计数值为0时，它的内存就会被释放掉。\n1 2 3 4 5  typedef struct _object { _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type; } PyObject;   以下情况会导致引用计数加1：\n 对象被创建 对象被引用 对象作为参数传入到一个函数中 对象作为元素存储到一个容器中  以下情况会导致引用计数减1：\n 用del语句显示删除对象引用 对象引用被重新赋值其他对象 一个对象离开它所在的作用域 持有该对象的容器自身被销毁 持有该对象的容器删除该对象  可以通过sys模块的getrefcount函数来获得对象的引用计数。引用计数的内存管理方式在遇到循环引用的时候就会出现致命伤，因此需要其他的垃圾回收算法对其进行补充。\n标记清理：CPython使用了“标记-清理”（Mark and Sweep）算法解决容器类型可能产生的循环引用问题。该算法在垃圾回收时分为两个阶段：标记阶段，遍历所有的对象，如果对象是可达的（被其他对象引用），那么就标记该对象为可达；清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。CPython底层维护了两个双端链表，一个链表存放着需要被扫描的容器对象（姑且称之为链表A），另一个链表存放着临时不可达对象（姑且称之为链表B）。为了实现“标记-清理”算法，链表中的每个节点除了有记录当前引用计数的ref_count变量外，还有一个gc_ref变量，这个gc_ref是ref_count的一个副本，所以初始值为ref_count的大小。执行垃圾回收时，首先遍历链表A中的节点，并且将当前对象所引用的所有对象的gc_ref减1，这一步主要作用是解除循环引用对引用计数的影响。再次遍历链表A中的节点，如果节点的gc_ref值为0，那么这个对象就被标记为“暂时不可达”（GC_TENTATIVELY_UNREACHABLE）并被移动到链表B中；如果节点的gc_ref不为0，那么这个对象就会被标记为“可达“（GC_REACHABLE），对于”可达“对象，还要递归的将该节点可以到达的节点标记为”可达“；链表B中被标记为”可达“的节点要重新放回到链表A中。在两次遍历之后，链表B中的节点就是需要释放内存的节点。\n分代回收：在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过分代回收（空间换时间）的方法提高垃圾回收效率。分代回收的基本思想是：对象存在的时间越长，是垃圾的可能性就越小，应该尽量不对这样的对象进行垃圾回收。CPython将对象分为三种世代分别记为0、1、2，每一个新生对象都在第0代中，如果该对象在一轮垃圾回收扫描中存活下来，那么它将被移到第1代中，存在于第1代的对象将较少的被垃圾回收扫描到；如果在对第1代进行垃圾回收扫描时，这个对象又存活下来，那么它将被移至第2代中，在那里它被垃圾回收扫描的次数将会更少。分代回收扫描的门限值可以通过gc模块的get_threshold函数来获得，该函数返回一个三元组，分别表示多少次内存分配操作后会执行0代垃圾回收，多少次0代垃圾回收后会执行1代垃圾回收，多少次1代垃圾回收后会执行2代垃圾回收。需要说明的是，如果执行一次2代垃圾回收，那么比它年轻的代都要执行垃圾回收。如果想修改这几个门限值，可以通过gc模块的set_threshold函数来做到。\n题目008：说一下你对Python中迭代器和生成器的理解。  点评：很多人面试者都会写迭代器和生成器，但是却无法准确的解释什么是迭代器和生成器。如果你也有同样的困惑，可以参考下面的回答。\n 迭代器是实现了迭代器协议的对象。跟其他编程语言不通，Python中没有用于定义协议或表示约定的关键字，像interface、protocol这些单词并不在Python语言的关键字列表中。Python语言通过魔法方法来表示约定，也就是我们所说的协议，而__next__和__iter__这两个魔法方法就代表了迭代器协议。可以通过for-in循环从迭代器对象中取出值，也可以使用next函数取出迭代器对象中的下一个值。生成器是迭代器的语法升级版本，可以用更为简单的代码来实现一个迭代器。\n 扩展：面试中经常让写生成斐波那契数列的迭代器，大家可以参考下面的代码。\n      class Fib(object):\ndef __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx \u0026lt; self.num: self.a, self.b = self.b, self.a + self.b self.idx += 1 return self.a raise StopIteration()   \u0026gt; 如果用生成器的语法来改写上面的代码，代码会简单优雅很多。 \u0026gt; ```python def fib(num): a, b = 0, 1 for _ in range(num): a, b = b, a + b yield a 题目009：正则表达式的match方法和search方法有什么区别？  点评：正则表达式是字符串处理的重要工具，所以也是面试中经常考察的知识点。在Python中，使用正则表达式有两种方式，一种是直接调用re模块中的函数，传入正则表达式和需要处理的字符串；一种是先通过re模块的compile函数创建正则表达式对象，然后再通过对象调用方法并传入需要处理的字符串。如果一个正则表达式被频繁的使用，我们推荐用re.compile函数创建正则表达式对象，这样会减少频繁编译同一个正则表达式所造成的开销。\n match方法是从字符串的起始位置进行正则表达式匹配，返回Match对象或None。search方法会扫描整个字符串来找寻匹配的模式，同样也是返回Match对象或None。\n题目010：下面这段代码的执行结果是什么。 1 2 3 4  def multiply(): return [lambda x: i * x for i in range(4)] print([m(100) for m in multiply()])   运行结果：\n[300, 300, 300, 300] 上面代码的运行结果很容易被误判为[0, 100, 200, 300]。首先需要注意的是multiply函数用生成式语法返回了一个列表，列表中保存了4个Lambda函数，这4个Lambda函数会返回传入的参数乘以i的结果。需要注意的是这里有闭包（closure）现象，multiply函数中的局部变量i的生命周期被延展了，由于i最终的值是3，所以通过m(100)调列表中的Lambda函数时会返回300，而且4个调用都是如此。\n如果想得到[0, 100, 200, 300]这个结果，可以按照下面几种方式来修改multiply函数。\n方法一：使用生成器，让函数获得i的当前值。\n1 2 3 4  def multiply(): return (lambda x: i * x for i in range(4)) print([m(100) for m in multiply()])   或者\n1 2 3 4 5  def multiply(): for i in range(4): yield lambda x: x * i print([m(100) for m in multiply()])   方法二：使用偏函数，彻底避开闭包。\n1 2 3 4 5 6 7  from functools import partial from operator import __mul__ def multiply(): return [partial(__mul__, i) for i in range(4)] print([m(100) for m in multiply()])   题目011：Python中为什么没有函数重载？  点评：C++、Java、C#等诸多编程语言都支持函数重载，所谓函数重载指的是在同一个作用域中有多个同名函数，它们拥有不同的参数列表（参数个数不同或参数类型不同或二者皆不同），可以相互区分。重载也是一种多态性，因为通常是在编译时通过参数的个数和类型来确定到底调用哪个重载函数，所以也被称为编译时多态性或者叫前绑定。这个问题的潜台词其实是问面试者是否有其他编程语言的经验，是否理解Python是动态类型语言，是否知道Python中函数的可变参数、关键字参数这些概念。\n 首先Python是解释型语言，函数重载现象通常出现在编译型语言中。其次Python是动态类型语言，函数的参数没有类型约束，也就无法根据参数类型来区分重载。再者Python中函数的参数可以有默认值，可以使用可变参数和关键字参数，因此即便没有函数重载，也要可以让一个函数根据调用者传入的参数产生不同的行为。\n题目012：用Python代码实现Python内置函数max。  点评：这个题目看似简单，但实际上还是比较考察面试者的功底。因为Python内置的max函数既可以传入可迭代对象找出最大，又可以传入两个或多个参数找出最大；最为关键的是还可以通过命名关键字参数key来指定一个用于元素比较的函数，还可以通过default命名关键字参数来指定当可迭代对象为空时返回的默认值。\n 下面的代码仅供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def my_max(*args, key=None, default=None): \u0026#34;\u0026#34;\u0026#34; 获取可迭代对象中最大的元素或两个及以上实参中最大的元素 :param args: 一个可迭代对象或多个元素 :param key: 提取用于元素比较的特征值的函数，默认为None :param default: 如果可迭代对象为空则返回该默认值，如果没有给默认值则引发ValueError异常 :return: 返回可迭代对象或多个元素中的最大元素 \u0026#34;\u0026#34;\u0026#34; if len(args) == 1 and len(args[0]) == 0: if default: return default else: raise ValueError(\u0026#39;max() arg is an empty sequence\u0026#39;) items = args[0] if len(args) == 1 else args max_elem, max_value = items[0], items[0] if key: max_value = key(max_value) for item in items: value = item if key: value = key(item) if value \u0026gt; max_value: max_elem, max_value = item, value return max_elem   题目013：写一个函数统计传入的列表中每个数字出现的次数并返回对应的字典。  点评：送人头的题目，不解释。\n 1 2 3 4 5 6  def count_letters(items): result = {} for item in items: if isinstance(item, (int, float)): result[item] = result.get(item, 0) + 1 return result   也可以直接使用Python标准库中collections模块的Counter类来解决这个问题，Counter是dict的子类，它会将传入的序列中的每个元素作为键，元素出现的次数作为值来构造字典。\n1 2 3 4 5 6  from collections import Counter def count_letters(items): counter = Counter(items) return {key: value for key, value in counter.items() \\ if isinstance(key, (int, float))}   题目014：使用Python代码实现遍历一个文件夹的操作。  点评：基本也是送人头的题目，只要用过os模块就应该知道怎么做。\n Python标准库os模块的walk函数提供了遍历一个文件夹的功能，它返回一个生成器。\n1 2 3 4 5 6 7 8  import os g = os.walk(\u0026#39;/Users/Hao/Downloads/\u0026#39;) for path, dir_list, file_list in g: for dir_name in dir_list: print(os.path.join(path, dir_name)) for file_name in file_list: print(os.path.join(path, file_name))    说明：os.path模块提供了很多进行路径操作的工具函数，在项目开发中也是经常会用到的。如果题目明确要求不能使用os.walk函数，那么可以使用os.listdir函数来获取指定目录下的文件和文件夹，然后再通过循环遍历用os.isdir函数判断哪些是文件夹，对于文件夹可以通过递归调用进行遍历，这样也可以实现遍历一个文件夹的操作。\n 题目015：现有2元、3元、5元共三种面额的货币，如果需要找零99元，一共有多少种找零的方式？  点评：还有一个非常类似的题目：“一个小朋友走楼梯，一次可以走1个台阶、2个台阶或3个台阶，问走完10个台阶一共有多少种走法？”，这两个题目的思路是一样，如果用递归函数来写的话非常简单。\n 1 2 3 4 5 6 7 8 9 10 11  from functools import lru_cache @lru_cache() def change_money(total): if total == 0: return 1 if total \u0026lt; 0: return 0 return change_money(total - 2) + change_money(total - 3) + \\ change_money(total - 5)    说明：在上面的代码中，我们用lru_cache装饰器装饰了递归函数change_money，如果不做这个优化，上面代码的渐近时间复杂度将会是$O(3^N)$，而如果参数total的值是99，这个运算量是非常巨大的。lru_cache装饰器会缓存函数的执行结果，这样就可以减少重复运算所造成的开销，这是空间换时间的策略，也是动态规划的编程思想。\n 题目016：写一个函数，给定矩阵的阶数n，输出一个螺旋式数字矩阵。  例如：n = 2，返回：\n   1 2 4 3\n \u0026gt; 例如：n = 3，返回： \u0026gt; ``` 1 2 3 8 9 4 7 6 5 这个题目本身并不复杂，下面的代码仅供参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  def show_spiral_matrix(n): matrix = [[0] * n for _ in range(n)] row, col = 0, 0 num, direction = 1, 0 while num \u0026lt;= n ** 2: if matrix[row][col] == 0: matrix[row][col] = num num += 1 if direction == 0: if col \u0026lt; n - 1 and matrix[row][col + 1] == 0: col += 1 else: direction += 1 elif direction == 1: if row \u0026lt; n - 1 and matrix[row + 1][col] == 0: row += 1 else: direction += 1 elif direction == 2: if col \u0026gt; 0 and matrix[row][col - 1] == 0: col -= 1 else: direction += 1 else: if row \u0026gt; 0 and matrix[row - 1][col] == 0: row -= 1 else: direction += 1 direction %= 4 for x in matrix: for y in x: print(y, end=\u0026#39;\\t\u0026#39;) print()   题目017：阅读下面的代码，写出程序的运行结果。 1 2 3 4 5 6  items = [1, 2, 3, 4] print([i for i in items if i \u0026gt; 2]) print([i for i in items if i % 2]) print([(x, y) for x, y in zip(\u0026#39;abcd\u0026#39;, (1, 2, 3, 4, 5))]) print({x: f\u0026#39;item{x ** 2}\u0026#39; for x in (2, 4, 6)}) print(len({x for x in \u0026#39;hello world\u0026#39; if x not in \u0026#39;abcdefg\u0026#39;}))    点评：生成式（推导式）属于Python的特色语法之一，几乎是面试必考内容。Python中通过生成式字面量语法，可以创建出列表、集合、字典。\n [3, 4] [1, 3] [('a', 1), ('b', 2), ('c', 3), ('d', 4)] {2: 'item4', 4: 'item16', 6: 'item36'} 6 题目018：说出下面代码的运行结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Parent: x = 1 class Child1(Parent): pass class Child2(Parent): pass print(Parent.x, Child1.x, Child2.x) Child1.x = 2 print(Parent.x, Child1.x, Child2.x) Parent.x = 3 print(Parent.x, Child1.x, Child2.x)    点评：运行上面的代码首先输出1 1 1，这一点大家应该没有什么疑问。接下来，通过Child1.x = 2给类Child1重新绑定了属性x并赋值为2，所以Child1.x会输出2，而Parent和Child2并不受影响。执行Parent.x = 3会重新给Parent类的x属性赋值为3，由于Child2的x属性继承自Parent，所以Child2.x的值也是3；而之前我们为Child1重新绑定了x属性，那么它的x属性值不会受到Parent.x = 3的影响，还是之前的值2。\n 1 1 1 1 2 1 3 2 3 题目19：说说你用过Python标准库中的哪些模块。  点评：Python标准库中的模块非常多，建议大家根据自己过往的项目经历来介绍你用过的标准库和三方库，因为这些是你最为熟悉的，经得起面试官深挖的。\n    模块名 介绍     sys 跟Python解释器相关的变量和函数，例如：sys.version、sys.exit()   os 和操作系统相关的功能，例如：os.listdir()、os.remove()   re 和正则表达式相关的功能，例如：re.compile()、re.search()   math 和数学运算相关的功能，例如：math.pi、math.e、math.cos   logging 和日志系统相关的类和函数，例如：logging.Logger、logging.Handler   json / pickle 实现对象序列化和反序列的模块，例如：json.loads、json.dumps   hashlib 封装了多种哈希摘要算法的模块，例如：hashlib.md5、hashlib.sha1   urllib 包含了和URL相关的子模块，例如：urllib.request、urllib.parse   itertools 提供各种迭代器的模块，例如：itertools.cycle、itertools.product   functools 函数相关工具模块，例如：functools.partial、functools.lru_cache   collections / heapq 封装了常用数据结构和算法的模块，例如：collections.deque   threading / multiprocessing 多线程/多进程相关类和函数的模块，例如：threading.Thread   concurrent.futures / asyncio 并发编程/异步编程相关的类和函数的模块，例如：ThreadPoolExecutor   base64 提供BASE-64编码相关函数的模块，例如：bas64.encode   csv 和读写CSV文件相关的模块，例如：csv.reader、csv.writer   profile / cProfile / pstats 和代码性能剖析相关的模块，例如：cProfile.run、pstats.Stats   unittest 和单元测试相关的模块，例如：unittest.TestCase    题目20：__init__和__new__方法有什么区别？ Python中调用构造器创建对象属于两阶段构造过程，首先执行__new__方法获得保存对象所需的内存空间，再通过__init__执行对内存空间数据的填充（对象属性的初始化）。__new__方法的返回值是创建好的Python对象（的引用），而__init__方法的第一个参数就是这个对象（的引用），所以在__init__中可以完成对对象的初始化操作。__new__是类方法，它的第一个参数是类，__init__是对象方法，它的第一个参数是对象。\n题目21：输入年月日，判断这个日期是这一年的第几天。 方法一：不使用标准库中的模块和函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13  def is_leap_year(year): \u0026#34;\u0026#34;\u0026#34;判断指定的年份是不是闰年，平年返回False，闰年返回True\u0026#34;\u0026#34;\u0026#34; return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): \u0026#34;\u0026#34;\u0026#34;计算传入的日期是这一年的第几天\u0026#34;\u0026#34;\u0026#34; # 用嵌套的列表保存平年和闰年每个月的天数 days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ] days = days_of_month[is_leap_year(year)][:month - 1] return sum(days) + date   方法二：使用标准库中的datetime模块。\n1 2 3 4 5 6  import datetime def which_day(year, month, date): end = datetime.date(year, month, date) start = datetime.date(year, 1, 1) return (end - start).days + 1   题目22：平常工作中用什么工具进行静态代码分析。  点评：静态代码分析工具可以从代码中提炼出各种静态属性，这使得开发者可以对代码的复杂性、可维护性和可读性有更好的了解，这里所说的静态属性包括：\n   代码是否符合编码规范，例如：PEP-8。 代码中潜在的问题，包括：语法错误、缩进问题、导入缺失、变量覆盖等。 代码中的坏味道。 代码的复杂度。 代码的逻辑问题。   工作中静态代码分析主要用到的是Pylint和Flake8。Pylint可以检查出代码错误、坏味道、不规范的代码等问题，较新的版本中还提供了代码复杂度统计数据，可以生成检查报告。Flake8封装了Pyflakes（检查代码逻辑错误）、McCabe（检查代码复杂性）和Pycodestyle（检查代码是否符合PEP-8规范）工具，它可以执行这三个工具提供的检查。\n题目23：说一下你知道的Python中的魔术方法。  点评：魔术方法也称为魔法方法，是Python中的特色语法，也是面试中的高频问题。\n    魔术方法 作用     __new__、__init__、__del__ 创建和销毁对象相关   __add__、__sub__、__mul__、__div__、__floordiv__、__mod__ 算术运算符相关   __eq__、__ne__、__lt__、__gt__、__le__、__ge__ 关系运算符相关   __pos__、__neg__、__invert__ 一元运算符相关   __lshift__、__rshift__、__and__、__or__、__xor__ 位运算相关   __enter__、__exit__ 上下文管理器协议   __iter__、__next__、__reversed__ 迭代器协议   __int__、__long__、__float__、__oct__、__hex__ 类型/进制转换相关   __str__、__repr__、__hash__、__dir__ 对象表述相关   __len__、__getitem__、__setitem__、__contains__、__missing__ 序列相关   __copy__、__deepcopy__ 对象拷贝相关   __call__、__setattr__、__getattr__、__delattr__ 其他魔术方法    题目24：函数参数*arg和**kwargs分别代表什么？ Python中，函数的参数分为位置参数、可变参数、关键字参数、命名关键字参数。*args代表可变参数，可以接收0个或任意多个参数，当不确定调用者会传入多少个位置参数时，就可以使用可变参数，它会将传入的参数打包成一个元组。**kwargs代表关键字参数，可以接收用参数名=参数值的方式传入的参数，传入的参数的会打包成一个字典。定义函数时如果同时使用*args和**kwargs，那么函数可以接收任意参数。\n题目25：写一个记录函数执行时间的装饰器。  点评：高频面试题，也是最简单的装饰器，面试者必须要掌握的内容。\n 方法一：用函数实现装饰器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  from functools import wraps from time import time def record_time(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) print(f\u0026#39;{func.__name__}执行时间: {time() - start}秒\u0026#39;) return result return wrapper   方法二：用类实现装饰器。类有__call__魔术方法，该类对象就是可调用对象，可以当做装饰器来使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from functools import wraps from time import time class Record: def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) print(f\u0026#39;{func.__name__}执行时间: {time() - start}秒\u0026#39;) return result return wrapper    说明：装饰器可以用来装饰类或函数，为其提供额外的能力，属于设计模式中的代理模式。\n  扩展：装饰器本身也可以参数化，例如上面的例子中，如果不希望在终端中显示函数的执行时间而是希望由调用者来决定如何输出函数的执行时间，可以通过参数化装饰器的方式来做到，代码如下所示。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from functools import wraps from time import time def record_time(output): \u0026#34;\u0026#34;\u0026#34;可以参数化的装饰器\u0026#34;\u0026#34;\u0026#34; def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapper return decorate   题目26：什么是鸭子类型（duck typing）？ 鸭子类型是动态类型语言判断一个对象是不是某种类型时使用的方法，也叫做鸭子判定法。简单的说，鸭子类型是指判断一只鸟是不是鸭子，我们只关心它游泳像不像鸭子、叫起来像不像鸭子、走路像不像鸭子就足够了。换言之，如果对象的行为跟我们的预期是一致的（能够接受某些消息），我们就认定它是某种类型的对象。\n在Python语言中，有很多bytes-like对象（如：bytes、bytearray、array.array、memoryview）、file-like对象（如：StringIO、BytesIO、GzipFile、socket）、path-like对象（如：str、bytes），其中file-like对象都能支持read和write操作，可以像文件一样读写，这就是所谓的对象有鸭子的行为就可以判定为鸭子的判定方法。再比如Python中列表的extend方法，它需要的参数并不一定要是列表，只要是可迭代对象就没有问题。\n 说明：动态语言的鸭子类型使得设计模式的应用被大大简化。\n 题目27：说一下Python中变量的作用域。 Python中有四种作用域，分别是局部作用域（Local）、嵌套作用域（Embedded）、全局作用域（Global）、内置作用域（Built-in），搜索一个标识符时，会按照LEGB的顺序进行搜索，如果所有的作用域中都没有找到这个标识符，就会引发NameError异常。\n题目28：说一下你对闭包的理解。 闭包是支持一等函数的编程语言（Python、JavaScript等）中实现词法绑定的一种技术。当捕捉闭包的时候，它的自由变量（在函数外部定义但在函数内部使用的变量）会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。简单的说，可以将闭包理解为能够读取其他函数内部变量的函数。正在情况下，函数的局部变量在函数调用结束之后就结束了生命周期，但是闭包使得局部变量的生命周期得到了延展。使用闭包的时候需要注意，闭包会使得函数中创建的对象不会被垃圾回收，可能会导致很大的内存开销，所以闭包一定不能滥用。\n题目29：说一下Python中的多线程和多进程的应用场景和优缺点。 线程是操作系统分配CPU的基本单位，进程是操作系统分配内存的基本单位。通常我们运行的程序会包含一个或多个进程，而每个进程中又包含一个或多个线程。多线程的优点在于多个线程可以共享进程的内存空间，所以进程间的通信非常容易实现；但是如果使用官方的CPython解释器，多线程受制于GIL（全局解释器锁），并不能利用CPU的多核特性，这是一个很大的问题。使用多进程可以充分利用CPU的多核特性，但是进程间通信相对比较麻烦，需要使用IPC机制（管道、套接字等）。\n多线程适合那些会花费大量时间在I/O操作上，但没有太多并行计算需求且不需占用太多内存的I/O密集型应用。多进程适合执行计算密集型任务（如：视频编码解码、数据处理、科学计算等）、可以分解为多个并行子任务并能合并子任务执行结果的任务以及在内存使用方面没有任何限制且不强依赖于I/O操作的任务。\n 扩展：Python中实现并发编程通常有多线程、多进程和异步编程三种选择。异步编程实现了协作式并发，通过多个相互协作的子程序的用户态切换，实现对CPU的高效利用，这种方式也是非常适合I/O密集型应用的。\n 题目30：说一下Python 2和Python 3的区别。  点评：这种问题千万不要背所谓的参考答案，说一些自己最熟悉的就足够了。\n  Python 2中的print和exec都是关键字，在Python 3中变成了函数。 Python 3中没有long类型，整数都是int类型。 Python 2中的不等号\u0026lt;\u0026gt;在Python 3中被废弃，统一使用!=。 Python 2中的xrange函数在Python 3中被range函数取代。 Python 3对Python 2中不安全的input函数做出了改进，废弃了raw_input函数。 Python 2中的file函数被Python 3中的open函数取代。 Python 2中的/运算对于int类型是整除，在Python 3中要用//来做整除除法。 Python 3中改进了Python 2捕获异常的代码，很明显Python 3的写法更合理。 Python 3生成式中循环变量的作用域得到了更好的控制，不会影响到生成式之外的同名变量。 Python 3中的round函数可以返回int或float类型，Python 2中的round函数返回float类型。 Python 3的str类型是Unicode字符串，Python 2的str类型是字节串，相当于Python 3中的bytes。 Python 3中的比较运算符必须比较同类对象。 Python 3中定义类的都是新式类，Python 2中定义的类有新式类（显式继承自object的类）和旧式类（经典类）之分，新式类和旧式类在MRO问题上有非常显著的区别，新式类可以使用__class__属性获取自身类型，新式类可以使用__slots__魔法。 Python 3对代码缩进的要求更加严格，如果混用空格和制表键会引发TabError。 Python 3中字典的keys、values、items方法都不再返回list对象，而是返回view object，内置的map、filter等函数也不再返回list对象，而是返回迭代器对象。 Python 3标准库中某些模块的名字跟Python 2是有区别的；而在三方库方面，有些三方库只支持Python 2，有些只能支持Python 3。  题目31：谈谈你对“猴子补丁”（monkey patching）的理解。 “猴子补丁”是动态类型语言的一个特性，代码运行时在不修改源代码的前提下改变代码中的方法、属性、函数等以达到热补丁（hot patch）的效果。很多系统的安全补丁也是通过猴子补丁的方式来实现的，但实际开发中应该避免对猴子补丁的使用，以免造成代码行为不一致的问题。\n在使用gevent库的时候，我们会在代码开头的地方执行gevent.monkey.patch_all()，这行代码的作用是把标准库中的socket模块给替换掉，这样我们在使用socket的时候，不用修改任何代码就可以实现对代码的协程化，达到提升性能的目的，这就是对猴子补丁的应用。\n另外，如果希望用ujson三方库替换掉标准库中的json，也可以使用猴子补丁的方式，代码如下所示。\n1 2 3 4 5  import json, ujson json.__name__ = \u0026#39;ujson\u0026#39; json.dumps = ujson.dumps json.loads = ujson.loads   单元测试中的Mock技术也是对猴子补丁的应用，Python中的unittest.mock模块就是解决单元测试中用Mock对象替代被测对象所依赖的对象的模块。\n题目32：阅读下面的代码说出运行结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class A: def who(self): print(\u0026#39;A\u0026#39;, end=\u0026#39;\u0026#39;) class B(A): def who(self): super(B, self).who() print(\u0026#39;B\u0026#39;, end=\u0026#39;\u0026#39;) class C(A): def who(self): super(C, self).who() print(\u0026#39;C\u0026#39;, end=\u0026#39;\u0026#39;) class D(B, C): def who(self): super(D, self).who() print(\u0026#39;D\u0026#39;, end=\u0026#39;\u0026#39;) item = D() item.who()    点评：这道题考查到了两个知识点：\n   Python中的MRO（方法解析顺序）。在没有多重继承的情况下，向对象发出一个消息，如果对象没有对应的方法，那么向上（父类）搜索的顺序是非常清晰的。如果向上追溯到object类（所有类的父类）都没有找到对应的方法，那么将会引发AttributeError异常。但是有多重继承尤其是出现菱形继承（钻石继承）的时候，向上追溯到底应该找到那个方法就得确定MRO。Python 3中的类以及Python 2中的新式类使用C3算法来确定MRO，它是一种类似于广度优先搜索的方法；Python 2中的旧式类（经典类）使用深度优先搜索来确定MRO。在搞不清楚MRO的情况下，可以使用类的mro方法或__mro__属性来获得类的MRO列表。 super()函数的使用。在使用super函数时，可以通过super(类型, 对象)来指定对哪个对象以哪个类为起点向上搜索父类方法。所以上面B类代码中的super(B, self).who()表示以B类为起点，向上搜索self（D类对象）的who方法，所以会找到C类中的who方法，因为D类对象的MRO列表是D --\u0026gt; B --\u0026gt; C --\u0026gt; A --\u0026gt; object。   ACBD 题目33：编写一个函数实现对逆波兰表达式求值，不能使用Python的内置函数。  点评：逆波兰表达式也称为“后缀表达式”，相较于平常我们使用的“中缀表达式”，逆波兰表达式不需要括号来确定运算的优先级，例如5 * (2 + 3)对应的逆波兰表达式是5 2 3 + *。逆波兰表达式求值需要借助栈结构，扫描表达式遇到运算数就入栈，遇到运算符就出栈两个元素做运算，将运算结果入栈。表达式扫描结束后，栈中只有一个数，这个数就是最终的运算结果，直接出栈即可。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import operator class Stack: \u0026#34;\u0026#34;\u0026#34;栈（FILO）\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.elems = [] def push(self, elem): \u0026#34;\u0026#34;\u0026#34;入栈\u0026#34;\u0026#34;\u0026#34; self.elems.append(elem) def pop(self): \u0026#34;\u0026#34;\u0026#34;出栈\u0026#34;\u0026#34;\u0026#34; return self.elems.pop() @property def is_empty(self): \u0026#34;\u0026#34;\u0026#34;检查栈是否为空\u0026#34;\u0026#34;\u0026#34; return len(self.elems) == 0 def eval_suffix(expr): \u0026#34;\u0026#34;\u0026#34;逆波兰表达式求值\u0026#34;\u0026#34;\u0026#34; operators = { \u0026#39;+\u0026#39;: operator.add, \u0026#39;-\u0026#39;: operator.sub, \u0026#39;*\u0026#39;: operator.mul, \u0026#39;/\u0026#39;: operator.truediv } stack = Stack() for item in expr.split(): if item.isdigit(): stack.push(float(item)) else: num2 = stack.pop() num1 = stack.pop() stack.push(operators[item](num1, num2)) return stack.pop()   题目34：Python中如何实现字符串替换操作？ Python中实现字符串替换大致有两类方法：字符串的replace方法和正则表达式的sub方法。\n方法一：使用字符串的replace方法。\n1 2  message = \u0026#39;hello, world!\u0026#39; print(message.replace(\u0026#39;o\u0026#39;, \u0026#39;O\u0026#39;).replace(\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;).replace(\u0026#39;he\u0026#39;, \u0026#39;HE\u0026#39;))   方法二：使用正则表达式的sub方法。\n1 2 3 4 5  import re message = \u0026#39;hello, world!\u0026#39; pattern = re.compile(\u0026#39;[aeiou]\u0026#39;) print(pattern.sub(\u0026#39;#\u0026#39;, message))    扩展：还有一个相关的面试题，对保存文件名的列表排序，要求文件名按照字母表和数字大小进行排序，例如对于列表filenames = ['a12.txt', 'a8.txt', 'b10.txt', 'b2.txt', 'b19.txt', 'a3.txt']，排序的结果是['a3.txt', 'a8.txt', 'a12.txt', 'b2.txt', 'b10.txt', 'b19.txt']。提示一下，可以通过字符串替换的方式为文件名补位，根据补位后的文件名用sorted函数来排序，大家可以思考下这个问题如何解决。\n 题目35：如何剖析Python代码的执行性能？ 剖析代码性能可以使用Python标准库中的cProfile和pstats模块，cProfile的run函数可以执行代码并收集统计信息，创建出Stats对象并打印简单的剖析报告。Stats是pstats模块中的类，它是一个统计对象。当然，也可以使用三方工具line_profiler和memory_profiler来剖析每一行代码耗费的时间和内存，这两个三方工具都会用非常友好的方式输出剖析结构。如果使用PyCharm，可以利用“Run”菜单的“Profile”菜单项对代码进行性能分析，PyCharm中可以用表格或者调用图（Call Graph）的方式来显示性能剖析的结果。\n下面是使用cProfile剖析代码性能的例子。\nexample.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import cProfile def is_prime(num): for factor in range(2, int(num ** 0.5) + 1): if num % factor == 0: return False return True class PrimeIter: def __init__(self, total): self.counter = 0 self.current = 1 self.total = total def __iter__(self): return self def __next__(self): if self.counter \u0026lt; self.total: self.current += 1 while not is_prime(self.current): self.current += 1 self.counter += 1 return self.current raise StopIteration() cProfile.run(\u0026#39;list(PrimeIter(10000))\u0026#39;)   如果使用line_profiler三方工具，可以直接剖析is_prime函数每行代码的性能，需要给is_prime函数添加一个profiler装饰器，代码如下所示。\n1 2 3 4 5 6  @profiler def is_prime(num): for factor in range(2, int(num ** 0.5) + 1): if num % factor == 0: return False return True   安装line_profiler。\n1  pip install line_profiler   使用line_profiler。\n1  kernprof -lv example.py   运行结果如下所示。\nLine # Hits Time Per Hit % Time Line Contents ============================================================== 1 @profile 2 def is_prime(num): 3 86624 48420.0 0.6 50.5 for factor in range(2, int(num ** 0.5) + 1): 4 85624 44000.0 0.5 45.9 if num % factor == 0: 5 6918 3080.0 0.4 3.2 return False 6 1000 430.0 0.4 0.4 return True 题目36：如何使用random模块生成随机数、实现随机乱序和随机抽样？  点评：送人头的题目，因为Python标准库中的常用模块应该是Python开发者都比较熟悉的内容，这个问题回如果答不上来，整个面试基本也就砸锅了。\n  random.random()函数可以生成[0.0, 1.0)之间的随机浮点数。 random.uniform(a, b)函数可以生成[a, b]或[b, a]之间的随机浮点数。 random.randint(a, b)函数可以生成[a, b]或[b, a]之间的随机整数。 random.shuffle(x)函数可以实现对序列x的原地随机乱序。 random.choice(seq)函数可以从非空序列中取出一个随机元素。 random.choices(population, weights=None, *, cum_weights=None, k=1)函数可以从总体中随机抽取（有放回抽样）出容量为k的样本并返回样本的列表，可以通过参数指定个体的权重，如果没有指定权重，个体被选中的概率均等。 random.sample(population, k)函数可以从总体中随机抽取（无放回抽样）出容量为k的样本并返回样本的列表。   扩展：random模块提供的函数除了生成均匀分布的随机数外，还可以生成其他分布的随机数，例如random.gauss(mu, sigma)函数可以生成高斯分布（正态分布）的随机数；random.paretovariate(alpha)函数会生成帕累托分布的随机数；random.gammavariate(alpha, beta)函数会生成伽马分布的随机数。\n 题目37：解释一下线程池的工作原理。  点评：池化技术就是一种典型空间换时间的策略，我们使用的数据库连接池、线程池等都是池化技术的应用，Python标准库currrent.futures模块的ThreadPoolExecutor就是线程池的实现，如果要弄清楚它的工作原理，可以参考下面的内容。\n 线程池是一种用于减少线程本身创建和销毁造成的开销的技术，属于典型的空间换时间操作。如果应用程序需要频繁的将任务派发到线程中执行，线程池就是必选项，因为创建和释放线程涉及到大量的系统底层操作，开销较大，如果能够在应用程序工作期间，将创建和释放线程的操作变成预创建和借还操作，将大大减少底层开销。线程池在应用程序启动后，立即创建一定数量的线程，放入空闲队列中。这些线程最开始都处于阻塞状态，不会消耗CPU资源，但会占用少量的内存空间。当任务到来后，从队列中取出一个空闲线程，把任务派发到这个线程中运行，并将该线程标记为已占用。当线程池中所有的线程都被占用后，可以选择自动创建一定数量的新线程，用于处理更多的任务，也可以选择让任务排队等待直到有空闲的线程可用。在任务执行完毕后，线程并不退出结束，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程长时间处于闲置状态时，线程池可以自动销毁一部分线程，回收系统资源。基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小。\n一般线程池都必须具备下面几个组成部分：\n 线程池管理器：用于创建并管理线程池。 工作线程和线程队列：线程池中实际执行的线程以及保存这些线程的容器。 任务接口：将线程执行的任务抽象出来，形成任务接口，确保线程池与具体的任务无关。 任务队列：线程池中保存等待被执行的任务的容器。  题目38：举例说明什么情况下会出现KeyError、TypeError、ValueError。 举一个简单的例子，变量a是一个字典，执行int(a['x'])这个操作就有可能引发上述三种类型的异常。如果字典中没有键x，会引发KeyError；如果键x对应的值不是str、float、int、bool以及bytes-like类型，在调用int函数构造int类型的对象时，会引发TypeError；如果a[x]是一个字符串或者字节串，而对应的内容又无法处理成int时，将引发ValueError。\n题目39：说出下面代码的运行结果。 1 2 3 4 5 6 7 8 9 10  def extend_list(val, items=[]): items.append(val) return items list1 = extend_list(10) list2 = extend_list(123, []) list3 = extend_list(\u0026#39;a\u0026#39;) print(list1) print(list2) print(list3)    点评：Python函数在定义的时候，默认参数items的值就被计算出来了，即[]。因为默认参数items引用了对象[]，每次调用该函数，如果对items引用的列表进行了操作，下次调用时，默认参数还是引用之前的那个列表而不是重新赋值为[]，所以列表中会有之前添加的元素。如果通过传参的方式为items重新赋值，那么items将引用到新的列表对象，而不再引用默认的那个列表对象。这个题在面试中经常被问到，通常不建议使用容器类型的默认参数，像PyLint这样的代码检查工具也会对这种代码提出质疑和警告。\n [10, 'a'] [123] [10, 'a'] 题目40：如何读取大文件，例如内存只有4G，如何读取一个大小为8G的文件？ 很显然4G内存要一次性的加载大小为8G的文件是不现实的，遇到这种情况必须要考虑多次读取和分批次处理。在Python中读取文件可以先通过open函数获取文件对象，在读取文件时，可以通过read方法的size参数指定读取的大小，也可以通过seek方法的offset参数指定读取的位置，这样就可以控制单次读取数据的字节数和总字节数。除此之外，可以使用内置函数iter将文件对象处理成迭代器对象，每次只读取少量的数据进行处理，代码大致写法如下所示。\n1 2 3  with open(\u0026#39;...\u0026#39;, \u0026#39;rb\u0026#39;) as file: for data in iter(lambda: file.read(2097152), b\u0026#39;\u0026#39;): pass   在Linux系统上，可以通过split命令将大文件切割为小片，然后通过读取切割后的小文件对数据进行处理。例如下面的命令将名为filename的大文件切割为大小为512M的多个文件。\n1  split -b 512m filename   如果愿意， 也可以将名为filename的文件切割为10个文件，命令如下所示。\n1  split -n 10 filename    扩展：外部排序跟上述的情况非常类似，由于处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。“排序-归并算法”就是一种常用的外部排序策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件，然后在归并阶段将这些临时文件组合为一个大的有序文件，这个大的有序文件就是排序的结果。\n 题目41：说一下你对Python中模块和包的理解。 每个Python文件就是一个模块，而保存这些文件的文件夹就是一个包，但是这个作为Python包的文件夹必须要有一个名为__init__.py的文件，否则无法导入这个包。通常一个文件夹下还可以有子文件夹，这也就意味着一个包下还可以有子包，子包中的__init__.py并不是必须的。模块和包解决了Python中命名冲突的问题，不同的包下可以有同名的模块，不同的模块下可以有同名的变量、函数或类。在Python中可以使用import或from ... import ...来导入包和模块，在导入的时候还可以使用as关键字对包、模块、类、函数、变量等进行别名，从而彻底解决编程中尤其是多人协作团队开发时的命名冲突问题。\n题目42：说一下你知道的Python编码规范。  点评：企业的Python编码规范基本上是参照PEP-8或谷歌开源项目风格指南来制定的，后者还提到了可以使用Lint工具来检查代码的规范程度，面试的时候遇到这类问题，可以先说下这两个参照标准，然后挑重点说一下Python编码的注意事项。\n   空格的使用\n 使用空格来表示缩进而不要用制表符（Tab）。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。    标识符命名\n 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。    表达式和语句\n 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如：if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。    题目43：运行下面的代码是否会报错，如果报错请说明哪里有什么样的错，如果不报错请说出代码的执行结果。 1 2 3 4 5 6 7 8 9 10 11 12  class A: def __init__(self, value): self.__value = value @property def value(self): return self.__value obj = A(1) obj.__value = 2 print(obj.value) print(obj.__value)    点评：这道题有两个考察点，一个考察点是对_和__开头的对象属性访问权限以及@property装饰器的了解，另外一个考察的点是对动态语言的理解，不需要过多的解释。\n 1 2  扩展：如果不希望代码运行时动态的给对象添加新属性，可以在定义类时使用__slots__魔法。例如，我们可以在上面的A中添加一行__slots__ = ('__value', )，再次运行上面的代码，将会在原来的第10行处产生AttributeError错误。\n 题目44：对下面给出的字典按值从大到小对键进行排序。 1 2 3 4 5 6 7 8 9  prices = { \u0026#39;AAPL\u0026#39;: 191.88, \u0026#39;GOOG\u0026#39;: 1186.96, \u0026#39;IBM\u0026#39;: 149.24, \u0026#39;ORCL\u0026#39;: 48.44, \u0026#39;ACN\u0026#39;: 166.89, \u0026#39;FB\u0026#39;: 208.09, \u0026#39;SYMC\u0026#39;: 21.29 }    点评：sorted函数的高阶用法在面试的时候经常出现，key参数可以传入一个函数名或一个Lambda函数，该函数的返回值代表了在排序时比较元素的依据。\n 1  sorted(prices, key=lambda x: prices[x], reverse=True)   题目45：说一下namedtuple的用法和作用。  点评：Python标准库的collections模块提供了很多有用的数据结构，这些内容并不是每个开发者都清楚，就比如题目问到的namedtuple，在我参加过的面试中，90%的面试者都不能准确的说出它的作用和应用场景。此外，deque也是一个非常有用但又经常被忽视的类，还有Counter、OrderedDict 、defaultdict 、UserDict等类，大家清楚它们的用法吗？\n 在使用面向对象编程语言的时候，定义类是最常见的一件事情，有的时候，我们会用到只有属性没有方法的类，这种类的对象通常只用于组织数据，并不能接收消息，所以我们把这种类称为数据类或者退化的类，就像C语言中的结构体那样。我们并不建议使用这种退化的类，在Python中可以用namedtuple（命名元组）来替代这种类。\n1 2 3 4 5 6 7  from collections import namedtuple Card = namedtuple(\u0026#39;Card\u0026#39;, (\u0026#39;suite\u0026#39;, \u0026#39;face\u0026#39;)) card1 = Card(\u0026#39;红桃\u0026#39;, 13) card2 = Card(\u0026#39;草花\u0026#39;, 5) print(f\u0026#39;{card1.suite}{card1.face}\u0026#39;) print(f\u0026#39;{card2.suite}{card2.face}\u0026#39;)   命名元组与普通元组一样是不可变容器，一旦将数据存储在namedtuple的顶层属性中，数据就不能再修改了，也就意味着对象上的所有属性都遵循“一次写入，多次读取”的原则。和普通元组不同的是，命名元组中的数据有访问名称，可以通过名称而不是索引来获取保存的数据，不仅在操作上更加简单，代码的可读性也会更好。\n命名元组的本质就是一个类，所以它还可以作为父类创建子类。除此之外，命名元组内置了一系列的方法，例如，可以通过_asdict方法将命名元组处理成字典，也可以通过_replace方法创建命名元组对象的浅拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12  class MyCard(Card): def show(self): faces = [\u0026#39;\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;K\u0026#39;] return f\u0026#39;{self.suite}{faces[self.face]}\u0026#39; print(Card) # \u0026lt;class \u0026#39;__main__.Card\u0026#39;\u0026gt; card3 = MyCard(\u0026#39;方块\u0026#39;, 12) print(card3.show()) # 方块Q print(dict(card1._asdict())) # {\u0026#39;suite\u0026#39;: \u0026#39;红桃\u0026#39;, \u0026#39;face\u0026#39;: 13} print(card2._replace(suite=\u0026#39;方块\u0026#39;)) # Card(suite=\u0026#39;方块\u0026#39;, face=5)   总而言之，命名元组能更好的组织数据结构，让代码更加清晰和可读，在很多场景下是元组、字典和数据类的替代品。在需要创建占用空间更少的不可变类时，命名元组就是很好的选择。\n题目46：按照题目要求写出对应的函数。  要求：写一个函数，传入一个有若干个整数的列表，该列表中某个元素出现的次数超过了50%，返回这个元素。\n 1 2 3 4 5 6 7 8 9 10 11 12  def more_than_half(items): temp, times = None, 0 for item in items: if times == 0: temp = item times += 1 else: if item == temp: times += 1 else: times -= 1 return temp    点评：LeetCode上的题目，在Python面试中出现过，利用元素出现次数超过了50%这一特征，出现和temp相同的元素就将计数值加1，出现和temp不同的元素就将计数值减1。如果计数值为0，说明之前出现的元素已经对最终的结果没有影响，用temp记下当前元素并将计数值置为1。最终，出现次数超过了50%的这个元素一定会被赋值给变量temp。\n 题目47：按照题目要求写出对应的函数。  要求：写一个函数，传入的参数是一个列表（列表中的元素可能也是一个列表），返回该列表最大的嵌套深度。例如：列表[1, 2, 3]的嵌套深度为1，列表[[1], [2, [3]]]的嵌套深度为3。\n 1 2 3 4 5 6 7  def list_depth(items): if isinstance(items, list): max_depth = 1 for item in items: max_depth = max(list_depth(item) + 1, max_depth) return max_depth return 0    点评：看到题目应该能够比较自然的想到使用递归的方式检查列表中的每个元素。\n 题目48：按照题目要求写出对应的装饰器。  要求：有一个通过网络获取数据的函数（可能会因为网络原因出现异常），写一个装饰器让这个函数在出现指定异常时可以重试指定的次数，并在每次重试之前随机延迟一段时间，最长延迟时间可以通过参数进行控制。\n 方法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from functools import wraps from random import random from time import sleep def retry(*, retry_times=3, max_wait_secs=5, errors=(Exception, )): def decorate(func): @wraps(func) def wrapper(*args, **kwargs): for _ in range(retry_times): try: return func(*args, **kwargs) except errors: sleep(random() * max_wait_secs) return None return wrapper return decorate   方法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from functools import wraps from random import random from time import sleep class Retry(object): def __init__(self, *, retry_times=3, max_wait_secs=5, errors=(Exception, )): self.retry_times = retry_times self.max_wait_secs = max_wait_secs self.errors = errors def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): for _ in range(self.retry_times): try: return func(*args, **kwargs) except self.errors: sleep(random() * self.max_wait_secs) return None return wrapper    点评：我们不止一次强调过，装饰器几乎是Python面试必问内容，这个题目比之前的题目稍微复杂一些，它需要的是一个参数化的装饰器。\n 题目49：写一个函数实现字符串反转，尽可能写出你知道的所有方法。  点评：烂大街的题目，基本上算是送人头的题目。\n 方法一：反向切片\n1 2  def reverse_string(content): return content[::-1]   方法二：反转拼接\n1 2  def reverse_string(content): return \u0026#39;\u0026#39;.join(reversed(content))   方法三：递归调用\n1 2 3 4  def reverse_string(content): if len(content) \u0026lt;= 1: return content return reverse_string(content[1:]) + content[0]   方法四：双端队列\n1 2 3 4 5 6  from collections import deque def reverse_string(content): q = deque() q.extendleft(content) return \u0026#39;\u0026#39;.join(q)   方法五：反向组装\n1 2 3 4 5 6 7  from io import StringIO def reverse_string(content): buffer = StringIO() for i in range(len(content) - 1, -1, -1): buffer.write(content[i]) return buffer.getvalue()   方法六：反转拼接\n1 2  def reverse_string(content): return \u0026#39;\u0026#39;.join([content[i] for i in range(len(content) - 1, -1, -1)])   方法七：半截交换\n1 2 3 4 5  def reverse_string(content): length, content= len(content), list(content) for i in range(length // 2): content[i], content[length - 1 - i] = content[length - 1 - i], content[i] return \u0026#39;\u0026#39;.join(content)   方法八：对位交换\n1 2 3 4 5  def reverse_string(content): length, content= len(content), list(content) for i, j in zip(range(length // 2), range(length - 1, length // 2 - 1, -1)): content[i], content[j] = content[j], content[i] return \u0026#39;\u0026#39;.join(content)    扩展：这些方法其实都是大同小异的，面试的时候能够给出几种有代表性的就足够了。给大家留一个思考题，上面这些方法，哪些做法的性能较好呢？我们之前提到过剖析代码性能的方法，大家可以用这些方法来检验下你给出的答案是否正确。\n 题目50：按照题目要求写出对应的函数。  要求：列表中有1000000个元素，取值范围是[1000, 10000)，设计一个函数找出列表中的重复元素。\n 1 2 3 4 5 6 7  def find_dup(items: list): dups = [0] * 9000 for item in items: dups[item - 1000] += 1 for idx, val in enumerate(dups): if val \u0026gt; 1: yield idx + 1000    点评：这道题的解法和计数排序的原理一致，虽然元素的数量非常多，但是取值范围[1000, 10000)并不是很大，只有9000个可能的取值，所以可以用一个能够保存9000个元素的dups列表来记录每个元素出现的次数，dups列表所有元素的初始值都是0，通过对items列表中元素的遍历，当出现某个元素时，将dups列表对应位置的值加1，最后dups列表中值大于1的元素对应的就是items列表中重复出现过的元素。\n 摘自《Python面试宝典》。\n","date":"2023-03-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python/python-meeting/","title":"Python 100道面试题-摘抄"},{"content":"Get-Content 将从文件读取的数据视为数组, 每行文件内容为一个数组元素\n传统的Cmd管道是基于文本的, 但是Powershell是基于对象的.\n  为什么可以通过notpad打开记事本, 不能通过wordpad打开写字板？\n因为notepad.exe位于C:Windows\\system32这个目录, 而这个目录已经默认被包含在Powershell的环境变量$env:Path中.\n而wordpad.exe所在的%ProgramFiles%\\Windows NT\\Accessories目录却没有包含,\n将wordpad所在的目录加入到环境变量中, $env:Path=$env:Path+\u0026quot;%ProgramFiles%\\Windows NT\\Accessories\u0026quot;.\n  常用的对管道结果进一步处理的命令有：\n   命令 解释     Compare-Object 比较两组对象.   ConvertTo-Html 将 Microsoft .NET Framework 对象转换为可在 Web 浏览器中显示的 HTML.   Export-Clixml 创建对象的基于 XML 的表示形式并将其存储在文件中.   Export-Csv 将 Microsoft .NET Framework 对象转换为一系列以逗号分隔的、长度可变的 (CSV) 字符串, 并将这些字符串保存到一个 CSV 文件中.   ForEach-Object 针对每一组输入对象执行操作.   Format-List 将输出的格式设置为属性列表, 其中每个属性均各占一行显示.   Format-Table 将输出的格式设置为表.   Format-Wide 将对象的格式设置为只能显示每个对象的一个属性的宽表.   Get-Unique 从排序列表返回唯一项目.   Group-Object 指定的属性包含相同值的组对象.   Import-Clixml 导入 CLIXML 文件, 并在 Windows PowerShell 中创建相应的对象.   Measure-Object 计算对象的数字属性以及字符串对象（如文本文件）中的字符数、单词数和行数.   more 对结果分屏显示.   Out-File 将输出发送到文件.   Out-Null 删除输出, 不将其发送到控制台.   Select-Object 选择一个对象或一组对象的指定属性.它还可以从对象的数组中选择唯一对象, 也可以从对象数组的开头或末尾选择指定个数的对象.   Sort-Object 按属性值对象进行排序.   Where-Object 创建控制哪些对象沿着命令管道传递的筛选器.    在ForEach-Object中, $_代表当前对象, 当然也允许通过$_,调用该对象支持的方法.\nGet-Content 逐行读取文本的内容, 然后把文本的每一行传递给管道.因此, 在你想读取一个长文件的前10行, 应当使用Select-Object:\nGet-Content $env:windir\\windowsupdate.log | Select-Object -first 10\n使用Select-String可以过滤出文本文件中的信息.下面的命令行会从windowsupdate.log文件中过滤出包含\u0026quot;added update\u0026quot;短语的行\n1 2 3 4  Get-Content $env:windir\\windowsupdate.log | Select-String \u0026#34;Added update\u0026#34; # 列出当前文件夹下所有powershell脚本, 并重命名为 Script1.ps1, Script2.ps1, Script3.ps1... ls $directory*.ps1 | ForEach-Object {$x=0} { Rename-Item $_ (\u0026#34;Script \u0026#34; + $x + \u0026#34;.ps1\u0026#34;); $x++ } {\u0026#34;Finished!\u0026#34;}    Windows 凭证管理 cmdkey.exe  建立, 显示, 并删除已储存的用户名称和密码\n 这个命令的语法为: CMDKEY [{/add | /generic}:targetname {/smartcard | /user:username {/pass{:password}}} | /delete{:targetname | /ras} | /list{:targetname}] 范例: 列出可用的认证:\n1 2  cmdkey /list cmdkey /list:targetname   建立一般认证: 可以用 /generic 参数来取代 /add 参数, 以建立一般认证\n删除现有认证:\n1 2 3  cmdkey /delete:targetname cmdkey /delete:Frank_Ma cmdkey /generic:Frank_Ma /user:username /pass:password   ","date":"2022-05-13T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-basic/","title":"Powershell 笔记"}]