[{"content":"apt(Advanced Package Tool) apt 是 Debian 系的Linux发行版默认的软件包管理器, 本文暂不讨论apt 和 apt-get 的关系与区别\napt命令必须以具有sudo权限的用户运行, 以下示例省略前面的sudo\nsearch apt search package_name\nshow apt show package_name 显示有关给定软件包的信息，包括其依赖项、安装、下载大小、软件包可用的来源、软件包内容的描述等\ninstall apt install package1 package2 安装软件包, 多个软件包名使用空格分隔\nupdate \u0026amp; upgrade apt update 从APT存储库中获取最新索引数据\napt upgrade 将已安装的软件包升级到最新版本\napt upgrade package_name 升级单个软件包\nlist apt list --installed 列出已安装的软件包\napt list --upgradeable 获取可升级软件包的列表\nremove \u0026amp; purge remove 和 purge 的区别: remove 保留软件包的配置文件, 而 purge 会卸载软件包并删除配置文件\nPS: 当我们安装了一个软件包, 发现某些设置和默认的设置不一致时, 需要注意是不是之前安装过这个软件, 然后使用remove删除, 重新安装之后使用了之前的配置文件导致的\napt remove package_name\napt purge package_name\nautoremove apt autoremove 用于删除某些(为了满足其他软件包依赖)自动安装的包\n","date":"2023-06-01T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/apt-cheat-sheet/","title":"apt Cheat Sheet"},{"content":"1 2 3 4  dt = {\u0026#39;sep\u0026#39;: \u0026#39; # \u0026#39;, \u0026#39;end\u0026#39;: \u0026#39;\\n\\n\u0026#39;} print(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, **dt) # 等价于 print(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;, sep=\u0026#39; # \u0026#39;, end=\u0026#39;\\n\\n\u0026#39;)   ","date":"2023-06-01T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python-kwargs/","title":"Python Kwargs"},{"content":"许多软件文档中, 代码示例的部分, 经常会使用 \u0026lsquo;foobar\u0026rsquo;或者 \u0026lsquo;foo\u0026rsquo;, \u0026lsquo;bar\u0026rsquo; 作为变量, 这两个单词具体是什么意思有点困惑, 词典给出的中文翻译都联系不上\n太长不看版:\n结合国情来理解, foo 和 bar 就是课文中的小明和小红, 罗翔刑法案例中的张三, 张宇高数课, 等价无穷小公式中的狗\n以下是维基百科给出的详细解释:\nFoobar - Wikipedia\n","date":"2023-05-31T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/foo-bar/","title":"编程文档中的 Foo Bar"},{"content":"VBA(For Excel) Excel 对象 单元格里的数据类型系统是根据数据内容确定的, 比如：你将 A 列单元格格式设为保留两位的数值型, 当你在 A1 输入 5 时, 它就显示为 5.00, 如果输入 ABC, 它就不会变成数值型, 而是文本型, 如果将文本改为数字后, 又回到你设置的保留两位小数格式所以单元格设置格式只能对能转换的数据有效(当你设置为文本型后，所有输入字符都能转换为文本，可以理解为文本型才是单元格真正能设置的格式)\n相对地址 \u0026amp; 绝对地址($) C2 = A2 * B2\nAUTOFILL: C3 = A3 * B3\nJ6 = I6 * $K$3 + I6\nAUTOFILL: J7 = I7 * $K$3 + I7\n引用单元格   A1 表示法\nRange(\u0026ldquo;A1\u0026rdquo;)\nRange(\u0026ldquo;A1:B5\u0026rdquo;)\nRange(\u0026ldquo;A1:B5,C1:D5\u0026rdquo;)\nRange(\u0026ldquo;A:A\u0026rdquo;)\nRange(\u0026ldquo;1:1\u0026rdquo;)\nRange(\u0026ldquo;A:C\u0026rdquo;)\nRange(\u0026ldquo;1:5\u0026rdquo;)\nRange(\u0026ldquo;1:1,3:3,8:8\u0026rdquo;)\nRange(\u0026ldquo;A:A,C:C,F:F\u0026rdquo;)\n  索引编号(适合用于循环)\nCells(6, 1)\n  快捷表示法\n[A1:B5]\n  相对引用\nOffset(Row, Col)\n  Range 表示连续的区域有两种表达:  Range(\u0026ldquo;起始单元格\u0026rdquo;,\u0026ldquo;结束单元格\u0026rdquo;) Range(\u0026ldquo;起始单元格:结束单元格\u0026rdquo;)  Range 表示非连续的区域: Range(\u0026ldquo;A1:A2, B3:B4\u0026rdquo;).Value = 10\n代码片段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  Sub rangeTest() Debug.Print Range(\u0026#34;a1: c5\u0026#34;).Address \u0026#39; $A$1:$C$5 End Sub Sub rangeTest() Dim num1 As Integer Dim letter1 As String Dim num2 As Integer Dim letter As String Let num1 = 1 Let letter1 = \u0026#34;a\u0026#34; Let letter2 = \u0026#34;c\u0026#34; Let num2 = 5 Range(Range(letter1 \u0026amp; num1), Range(letter2 \u0026amp; num2)).Select End Sub \u0026#39; 变量选择 Sub rangeTest() Dim num As Integer Dim letter As String Let letter = \u0026#34;a\u0026#34; Let num = 5 Range(letter \u0026amp; num).Select End Sub   浮点数比较 浮点数是不精确数据, 不能用等号判断是否相等\nbool isEqual = abs(f1-f2) \u0026lt;= epsilon\nDecimal 类型只能在 Variant 内使用\n不能直接声明Decimal类型\n先声明一个Variant, 再使用 Cdec()变成Decimal\n","date":"2023-05-30T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/vba-notebook/","title":"VBA Notebook"},{"content":"C# 中可以通过 Diagnostics.Process 类来实现调用外部的可执行文件\n下面是一段调用 PowerPoint 演示幻灯片的脚本:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using System.Diagnostics; namespace awake { class Program { static void Main(string[] args) { Process p = new Process(); // powershell 的命令行工具  p.StartInfo.FileName = \u0026#34;C:\\\\Program Files (x86)\\\\Microsoft Office\\\\Office16\\\\POWERPNT.EXE\u0026#34;; // /S 后面跟着命令的参数  p.StartInfo.Arguments = \u0026#34;/S \\\u0026#34;E:\\\\mail\\\\keep awake.pptx\\\u0026#34;\u0026#34;; p.StartInfo.CreateNoWindow = true; p.StartInfo.UseShellExecute = false; p.Start(); } } }   ","date":"2023-05-29T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/csharp-call-command-line/","title":"Csharp Call Command Line"},{"content":"规格  TOML 是大小写敏感的 TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档 空白是指制表符(0x09)或空格(0x20) 换行是指 LF(0x0A)或 CRLF(0x0D 0x0A) 使用 # 符号作为注释  键值对 TOML 文档最基本的构成区块是键值对, 键名和键值周围的空白会被忽略\n多次定义同一个key是非法的\n1  key = \u0026#34;value\u0026#34;   点分隔符 1 2 3 4  name = \u0026#34;Orange\u0026#34; physical.color = \u0026#34;orange\u0026#34; physical.shape = \u0026#34;round\u0026#34; site.\u0026#34;google.com\u0026#34; = true # 引号内的点不会作为分隔符   等价于\n1 2 3 4 5 6 7 8 9 10  { \u0026#34;name\u0026#34;: \u0026#34;Orange\u0026#34;, \u0026#34;physical\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;shape\u0026#34;: \u0026#34;round\u0026#34; }, \u0026#34;site\u0026#34;: { \u0026#34;google.com\u0026#34;: true } }   表 表（也被称为哈希表或字典）是键值对的集合 它们由表头定义，连同方括号作为单独的行出现 表头不同于数组，因为数组只有值 缩进会被忽略\n从表头下方, 直至下一个表头或者文件结束, 都是这个表的键值对\n1 2 3 4 5 6 7  [table-1] key1 = \u0026#34;some string\u0026#34; key2 = 123 [table-2] key1 = \u0026#34;another string\u0026#34; key2 = 456   等价于\n1 2 3 4 5 6 7 8 9 10  { \u0026#34;table-1\u0026#34;: { \u0026#34;key1\u0026#34;: \u0026#34;some string\u0026#34;, \u0026#34;key2\u0026#34;: 123 }, \u0026#34;table-2\u0026#34;: { \u0026#34;key1\u0026#34;: \u0026#34;another string\u0026#34;, \u0026#34;key2\u0026#34;: 456 } }   表数组 1 2 3 4 5 6 7 8  [[products]] name = \u0026#34;Hammer\u0026#34; sku = 738594937 [[products]] # 数组里的空表 [[products]] name = \u0026#34;Nail\u0026#34; sku = 284758393 color = \u0026#34;gray\u0026#34;   等价于\n1 2 3 4 5 6 7  { \u0026#34;products\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Hammer\u0026#34;, \u0026#34;sku\u0026#34;: 738594937 }, { }, { \u0026#34;name\u0026#34;: \u0026#34;Nail\u0026#34;, \u0026#34;sku\u0026#34;: 284758393, \u0026#34;color\u0026#34;: \u0026#34;gray\u0026#34; } ] }   TOML to JSON\n","date":"2023-05-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/toml/","title":"TOML"},{"content":"之前任职于一家台湾公司, 公司员工电脑默认的默认编码格式使用的是港台地区的 Big5 编码, 俗称 大五码, 且员工没有管理员权限, 不能修改, 而服务器使用的编码是GBK\n由于VBA年代比较久, 使用的还是代码页表示不同语言的字符集(GBK的代码页 950, Big5 的代码页面 936), 没有使用Unicode, 当在员工电脑录制编写的VBA脚本, 保存在xlsm文件中, 需要放到服务器上去执行时, 中文部分会显示乱码\n于是, 编写了下面这段代码来转换xlsm文件中的VBA脚本编码, 主要做了以下事情\n 将xlsm文件中的VBA代码导出为.bas代码文件 转换纯文本代码文件的编码格式 将转换编码之后的代码导入xlsm文件 生成exe后, 可以通过命令行执行, 也可以直接拖动图标将xlsm文件拖到生成的.exe文件上  如果有需求要批量导出xlsm文件中的脚本代码, 下面的代码修改一下也可以实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  using System; using System.IO; using System.Text; using Excel = Microsoft.Office.Interop.Excel; using Microsoft.Vbe.Interop; namespace XLSM_Big52GBK_Converter { class Program{ static void ConvertEncoding(string sourcePath, string destPath){ string content; content = File.ReadAllText(sourcePath, Encoding.GetEncoding(950)); File.WriteAllText(destPath, content, Encoding.GetEncoding(936)); } static void Watermark(){ Console.WriteLine(\u0026#34; ==========================\u0026#34;); Console.WriteLine(\u0026#34; \u0026gt;\u0026gt; Date: 2021/7/10 \u0026#34;); Console.WriteLine(\u0026#34; \u0026gt;\u0026gt; Author: Frank_Ma/WKS \u0026#34;); Console.WriteLine(\u0026#34; ==========================\u0026#34;); } static void End(){ Console.WriteLine(\u0026#34;OK\u0026#34;); Console.WriteLine(\u0026#34;Press Any Key to Close\u0026#34;); Console.ReadKey(); } static void Main(string[] args){ Watermark(); Excel.Application app = new Excel.Application(); app.DisplayAlerts = false; string oFilename, nFilename, dir, oBas, nBas; if (args.Length == 0){ Console.WriteLine(\u0026#34; 輸入xlsm文件的完整路徑:\u0026#34;); nFilename = Console.ReadLine(); } else{ nFilename = args[0]; } nFilename = nFilename.Trim(\u0026#39;\\\u0026#34;\u0026#39;); if (!nFilename.ToLower().EndsWith(\u0026#34;.xlsm\u0026#34;)){ return; } Console.WriteLine(\u0026#34;converting...\u0026#34;); dir = Path.GetDirectoryName(nFilename); oFilename = Path.Combine(dir, Path.GetFileNameWithoutExtension(nFilename) + \u0026#34;_old.xlsm\u0026#34;); oBas = Path.Combine(dir, \u0026#34;old.bas\u0026#34;); nBas = Path.Combine(dir, \u0026#34;new.bas\u0026#34;); File.Copy(nFilename, oFilename, true); Excel.Workbook oWb = app.Workbooks.Open(oFilename); Excel.Workbook nWb = app.Workbooks.Open(nFilename); foreach (VBComponent cp in nWb.VBProject.VBComponents){ if (cp.Type == vbext_ComponentType.vbext_ct_StdModule){ int n = cp.CodeModule.CountOfLines; cp.CodeModule.DeleteLines(1, n); } } foreach (VBComponent comp in oWb.VBProject.VBComponents){ if (comp.Type == vbext_ComponentType.vbext_ct_StdModule){ comp.Export(oBas); ConvertEncoding(oBas, nBas); nWb.VBProject.VBComponents.Item(comp.Name).CodeModule.AddFromFile(nBas); } } oWb.Close(false); nWb.Close(true); End(); } } }   VBA 实现Excel单元格(或者Word)中的繁简转换, 可以使用以下两种方法\n 调用 EXCEL 的 TCSCConv.SharedAddin, 对sheet内容进行繁简转换 调用系统API LCMapString 对String进行繁简转换  受限于本机非Unicode程式的编码格式, 可能会出现VBA本身就无法识别出简体中文的情况（当本机编码为big5时）\n1 2  Private Declare Function LCMapString Lib \u0026#34;kernel32\u0026#34; Alias \u0026#34;LCMapStringA\u0026#34; (ByVal Locale As Long, ByVal dwMapFlags As Long, ByVal lpSrcStr As String, ByVal cchSrc As Long, ByVal lpDestStr As String, ByVal cchDest As Long) As Long Private Declare Function lstrlen Lib \u0026#34;kernel32\u0026#34; Alias \u0026#34;lstrlenA\u0026#34; (ByVal lpString As String) As Long   ","date":"2023-05-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/convert-xlsm-macro-encoding/","title":"修改xlsm文件中的宏脚本编码"},{"content":"Nginx 反向代理的配置块内容通常如下:\n1 2 3  location [ = | ~ | ~* | ^~ ] uri { proxy_pass URL; }   proxy_pass 后面的 URL, 如果带 /, 表示绝对路径, 如果不带 /, 表示相对路径\n通常 URL = host[:port][path](中括号内的内容表示可选)\n如 https://www.example.com:8080/,\nhttps:// 是协议, www.example.com 是 host, 80 是 port, / 是 path\n  proxy_pass 后面的 URL 不包含 path 时, 如 https://www.example.com:8080\ntarget_url = URL + uri\n  proxy_pass 后面的 URL 包含 path 时, /也算(如 https://www.example.com/)\ntarget_url = URL.replace(uri, path)\n  以下这篇文章写得非常通俗易懂, 并且举了很详细的例子加以说明\nproxy_pass url 反向代理的坑 | Nginx 入门教程\n","date":"2023-05-24T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/nginx-proxy-pass/","title":"Nginx 反向代理中的路径问题"},{"content":"使用 ssh 客户端远程连接到服务器时, 默认情况下, 一段时间不操作, 没有向服务器发送指令, 就自动断开了连接, 需要重新登录\n使用过的客户端中, xshell 默认情况下是会自动发送心跳来保持连接, 其他的一些如 mobaxterm, windterm, windows terminal自带的ssh, 时间久没有操作都是会断开连接的, 需要手动设置, 以下是手动设置的方法\n 命令行参数设置  如果是在终端中使用ssh命令连接远程机器, 如在Windows Terminal中, 可以通过添加以下参数来设置每隔60秒向Server端发送一个空包以保持连接\n1  ssh -o ServerAliveInterval=60 root@127.0.0.1   使用以上参数只会对本次连接会话有效, 如果需要每次都自动保持连接, 可以使用下面的方法\n客户端.ssh/config文件设置  ~/.ssh/config 文件中添加ServerAliveInterval 60\nHost xxx HostName 127.0.0.1 User root ServerAliveInterval 60 ","date":"2023-05-19T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/ssh-timeout/","title":"关于SSH长时间无操作自动断开"},{"content":"测试 hugo 主题 stack 中的 bilibili 视频 shortcode\n\r\r","date":"2023-05-13T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/bilibili-video-test/","title":"Bilibili Video Test"},{"content":"在命令行下, 如何在GitHub单独下载一份文件\n1 2 3 4 5 6 7 8 9 10 11  # 下载到当前目录 wget https://raw.githubusercontent.com/\u0026lt;用户名\u0026gt;/\u0026lt;存储库名\u0026gt;/\u0026lt;分支名\u0026gt;/\u0026lt;文件路径\u0026gt;/\u0026lt;文件名\u0026gt; curl -O https://raw.githubusercontent.com/\u0026lt;用户名\u0026gt;/\u0026lt;存储库名\u0026gt;/\u0026lt;分支名\u0026gt;/\u0026lt;文件路径\u0026gt;/\u0026lt;文件名\u0026gt; # example wget https://raw.githubusercontent.com/curl/curl/master/README.md curl -O https://raw.githubusercontent.com/curl/curl/master/README.md # 下载到指定文件夹 $dest_folder = /root/ wget -P $dest_folder https://raw.githubusercontent.com/\u0026lt;用户名\u0026gt;/\u0026lt;存储库名\u0026gt;/\u0026lt;分支名\u0026gt;/\u0026lt;文件路径\u0026gt;/\u0026lt;文件名\u0026gt; curl -o $dest_folder https://raw.githubusercontent.com/\u0026lt;用户名\u0026gt;/\u0026lt;存储库名\u0026gt;/\u0026lt;分支名\u0026gt;/\u0026lt;文件路径\u0026gt;/\u0026lt;文件名\u0026gt;   https://raw.githubusercontent.com/curl/curl/master/README.md\nWindows PowerShell 中的 wget 和 curl, 并不是 Linux 平台下面的, 只是 Invoke-WebRequest 的别名\n","date":"2023-04-29T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/download-github-single-file/","title":"Download Github Single File"},{"content":"MIME 类型 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。\nMIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。\n浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。\n语法 MIME 类型通用结构：\n type/subtype\n MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 / 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。\nMIME类型对大小写不敏感，但是传统写法都是小写。\n两种主要的 MIME 类型在默认类型中扮演了重要的角色：\n text/plain 表示文本文件的默认值。 application/octet-stream 表示所有其他情况的默认值。  摘自 MIME 类型 | 菜鸟教程\n","date":"2023-04-28T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/mime/","title":"MIME"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  # -i 忽略大小写 grep -i ^DA demo.txt # Search only for the full word, -w # 仅匹配整个单词, 如下面的例子, \u0026#34;off\u0026#34; 不会被匹配到 grep -w \u0026#34;of\u0026#34; demo.txt # Display 3 lines after matching string, -A grep -A 3 \u0026#39;Exception\u0026#39; error.log # Display 4 lines before matching string, -B grep -B 4 \u0026#39;Exception\u0026#39; error.log # Display 5 lines around matching string, -C grep -C 5 \u0026#39;Exception\u0026#39; error.log # Recursive search (within subdirs), -r # -r 递归 grep -r \u0026#39;quickref.me\u0026#39; /var/log/nginx/ # -v 反向查找, 只打印不匹配的行 grep -v \u0026#39;warning\u0026#39; /var/log/syslog # Use regex (lines starting with \u0026#39;al\u0026#39;), -e # 正则表达式 grep -e \u0026#39;^al\u0026#39; filename # Extended regex (lines containing jason or jackson), -E grep -E \u0026#39;ja(s|cks)on\u0026#39; filename # -c 打印匹配的行数 grep -c \u0026#39;error\u0026#39; /var/log/syslog # -l 打印匹配的文件名 grep -l \u0026#39;robot\u0026#39; /var/log/* # Only show the matching part of the string, -o grep -o search_string filename # -n 显示匹配的行号 grep -n \u0026#34;go\u0026#34; demo.txt # print the file containing the query including thos within subdirs grep -r ^David ~/some_dir/* # print the name of the file(s) which matches the query # --file-with-matches grep -l ^David ~/some_dir/* # -L --files-without-match #  grep -rL \u0026#39;date = \u0026#39; ./content/*/*.md   Grep Command Cheat Sheet \u0026amp; Quick Reference\nshell脚本——grep详解 - 知乎\n","date":"2023-04-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/grep-cheat-sheet/","title":"Grep Cheat Sheet"},{"content":"PowerShell 脚本 删除重复文件(根据文件哈希值判重)\n1 2 3  $root_path = \u0026#34;D:\\folder_name\u0026#34; $log_file = \u0026#34;D:\\log_file.txt\u0026#34; ls $root_path -recurse | get-filehash | group -property hash | where { $_.count -gt 1 } | % { $_.group } | epcsv $log_file   ","date":"2023-04-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/powershell-remove-duplicate-files/","title":"Powershell Remove Duplicate Files"},{"content":"Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  find [path...] [options] [expression] # Wildcard find . -name \u0026#34;*.txt\u0026#34; find . -name \u0026#34;2020*.csv\u0026#34; find . -name \u0026#34;json_*\u0026#34; # regex # TODO # directory find . -type d # file find . -type f ## Size # Find all bigger than 10MB files, 查找大于10M的文件 find . -size +10M # Find all smaller than 10MB files, 查找小于10M的文件 find . -size -10M # Find Size between 100MB and 1GB, 查找大于100M且小于1G的文件 find . -size +100M -size -1G   multiple dirs \u0026amp; filenames 1 2 3 4 5  # Find files with multiple dirs find /opt /usr /var -name foo.scala -type f # Find files with .sh and .txt extensions find . -type f \\( -name \u0026#34;*.sh\u0026#34; -o -name \u0026#34;*.txt\u0026#34; \\)   Find and \u0026hellip; find and replace 1 2 3 4 5 6 7  # Find all files and modify the content const to let # s表示substitute, 替换操作 # g表示global, 全局替换 find ./ -type f -exec sed -i \u0026#39;s/const/let/g\u0026#39; {} \\; # Find readable and writable files and modify the content old to new find ./ -type f -readable -writable -exec sed -i \u0026#34;s/old/new/g\u0026#34; {} \\;   find and move 1 2 3  # Find and move it to a specific directory (/tmp/music) # {} 表示find找到的每一个文件名(相当于PowerShell中的 $_) find . -name \u0026#39;*.mp3\u0026#39; -exec mv {} /tmp/music \\;   Find and concatenate 1 2 3 4  # Merge all csv files in the download directory into merged.csv find download -type f -iname \u0026#39;*.csv\u0026#39; | xargs cat \u0026gt; merged.csv # Merge all sorted csv files in the download directory into merged.csv find download -type f -iname \u0026#39;*.csv\u0026#39; | sort | xargs cat \u0026gt; merged.csv   ","date":"2023-04-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/find-cheat-sheet/","title":"Find Cheat Sheet"},{"content":"1 2 3 4 5 6 7 8 9  # 新建会话 tmux new -s session_name # Attach to last session tmux a # Attach to a session with the name mysession tmux a -t mysession   常用快捷键 将当前会话与窗口分离\nCtrl+b d\n列出当前所有会话(此快捷键需要在tmux会话内执行)\nCtrl+b s\n划分左右两个窗格\nCtrl+b %\n划分上下两个窗格\nCtrl+b \u0026quot;\n关闭当前窗格\nCtrl+b x\n调整窗格大小 Ctrl+b Ctrl+方向键\ncopy mode 进入窗口之后不支持上下翻页, 使用以下快捷键进入 copy mode\nCtrl+b [\n按 q 退出\n参考 Tmux Cheat Sheet \u0026amp; Quick Reference\nTips tmux划分窗格后, 只能通过 Ctrl+b + 方向键 在不同的窗格之间切换光标焦点, 并且在tmux窗口中, 需要进入copy mode才能上下翻页, 所以个人在日常使用中, 并不会经常使用tmux的拆分窗格等功能, 更多的是使用客户端软件(如 xshell, Windows Terminal)自带的拆分窗口功能, 一个账号同时登录多个会话(不执行影响其他会话的命令), 切换窗口和翻页更方便\n","date":"2023-04-25T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/tmux/","title":"Tmux"},{"content":"Windows11 系统的笔记本电脑在使用电源时, 会出现偶尔屏幕变暗又恢复的情况\n解决方法:\n打开 设置 \u0026gt; 系统 \u0026gt; 屏幕, 点击亮度调节 右侧下拉选项, 取消勾选 通过优化显示的内容和亮度降低电池能耗\n","date":"2023-04-12T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/win11-brightness/","title":"Win11 Brightness"},{"content":"浏览器 WPS Office 及及大部分支持横向滚动的桌面端软件, 支持 Shift + 鼠标滚轮 实现横向滚动\nMicrosoft Office 的 Excel 横向滚动的方式是 Ctrl + Shift + 鼠标滚轮\n","date":"2023-04-11T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/microsoft-excel-scroll/","title":"Microsoft Excel 横向滚动"},{"content":"简介 tldr(Too Long; Didn\u0026rsquo;t Read) 是一个开源的命令行工具，提供简洁的命令行使用文档\ntldr 提供了 web端 tldr InBrowser.App, nodejs 和 python 客户端以及 PDF版本\n安装 1 2 3 4 5 6  # nodejs npm install tldr # python pip3 install tldr   使用 tldr sed sed Edit text in a scriptable manner. See also: `awk`, `ed`. More information: https://www.gnu.org/software/sed/manual/sed.html. - Replace all `apple` (basic regex) occurrences with `mango` (basic regex) in all input lines and print the result to `stdout`: command | sed 's/apple/mango/g' - Execute a specific script [f]ile and print the result to `stdout`: command | sed -f path/to/script.sed - Replace all `apple` (extended regex) occurrences with `APPLE` (extended regex) in all input lines and print the result to `stdout`: command | sed -E 's/(apple)/\\U\\1/g' - Print just a first line to `stdout`: command | sed -n '1p' - Replace all `apple` (basic regex) occurrences with `mango` (basic regex) in a specific file and overwrite the original file in place: sed -i 's/apple/mango/g' path/to/file ","date":"2023-04-10T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/tldr/","title":"tldr"},{"content":"Gpt-Mirror\n","date":"2023-04-09T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/gpt_mirror/","title":"Gpt_Mirror"},{"content":"\u0026ldquo;Everything\u0026rdquo; 是什么？ \u0026ldquo;Everything\u0026rdquo; 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。\n如何在运行 \u0026ldquo;Everything\u0026rdquo; 时屏蔽 UAC 警告？ \u0026ldquo;Everything\u0026rdquo; 需要管理员权限以便低级别读取 NTFS 分卷来 NTFS 索引。\nUAC 警告可以通过以标准用户运行 \u0026ldquo;Everything\u0026rdquo; 和安装 \u0026ldquo;Everything\u0026rdquo; 服务或不使用 NTFS 索引来避免。\n以标准用户运行 \u0026ldquo;Everything\u0026rdquo; 和安装 \u0026ldquo;Everything\u0026rdquo; 服务：\n在 \u0026ldquo;Everything\u0026rdquo; 中，打开工具菜单，点击选项。\n  点击常规页面。\n  检查 Everything 服务。\n  取消以管理员方式运行。\n  点击确定。\n  退出 \u0026ldquo;Everything\u0026rdquo; (右键 Everything 托盘图标并点击退出)。\n  重启 Everything。\n  搜索 \u0026ldquo;Everything\u0026rdquo; 能否搜索文件内容？ 可以，\u0026ldquo;Everything\u0026rdquo; 可以通过搜索函数 content: 来搜索文件内容。\n文件内容未被索引时，搜索内容将会很慢。\n如何使用通配符？ 搜索关键词中使用通配符 * 将会匹配任意数量的任意字符。\n例如，搜索以 e 开头并以 g 结尾的文件和文件夹：e*g\n搜索关键词中使用通配符 ? 将会匹配任一字符。\n例如，搜索含有两个字符扩展名的文件：*.??\n如何搜索文件类型？ 搜索文件类型，请在搜索框输入扩展名，\n例如，搜索 mp3 文件，输入 *.mp3 即可。\n搜索多个文件类型，请使用 | 分隔，\n例如：*.bmp|*.jpg 将会搜索 bmp 或 jpg 类型文件。\n","date":"2023-04-03T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/everything-search-tool/","title":"Everything Search Tool"},{"content":"Get-History PowerShell 的 Get-History 命令只显示当前会话的历史命令\nPowerShell 没有类似 Linux bash 下的 history 一样, 直接查看所有会话的历史命令的 Cmdlet\n但是和 bash 一样, PowerShell 将所有会话的命令历史记录存储在文本文件中\n这个文件的路径可以通过命令 (Get-PSReadlineOption).HistorySavePath 获取到\nGet-PSReadlineOption Get-PSReadlineOption 命令 包含在 PSReadLine 模块下, 该模块需要 PowerShell 5.1 或更高的版本\n可以通过以下命令来实现查看所有命令历史记录\n1  Get-Content (Get-PSReadlineOption).HistorySavePath   需要注意的是, 如果历史命令中包含中文等非ASCII字符, 需要使用对应的编码读取该文本文件, 否则会显示乱码\nPowerShell 5.1 中 Get-Content 命令的 -Encoding 参数默认是 Default\nDefault 使用与系统的活动代码页相对应的编码 (通常为 ANSI)\n而在 PowerShell 7.2 中, Get-Content 命令的 -Encoding 参数默认是 utf8NoBOM\nutf8NoBOM：以 UTF-8 格式编码，不带字节顺序标记 (BOM)\n","date":"2023-04-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/powershell-history/","title":"PowerShell History"},{"content":"简短说明 介绍如何创建和使用 PowerShell 配置文件\n长说明 PowerShell 配置文件是在 PowerShell 启动时运行的脚本。 可以使用配置文件作为启动脚本来自定义环境。 可以添加命令、别名、函数、变量、模块、PowerShell 驱动器等。 还可以将其他特定于会话的元素添加到配置文件中，使其在每个会话中可用，而无需导入或重新创建它们。 PowerShell 支持用户和主机程序的多个配置文件。 但是，它不会为你创建配置文件。\n$PROFILE 变量 变量 $PROFILE 存储 当前用户，当前主机 配置文件 的路径。\n其他配置文件保存在 变量的注释属性中, 可通过以下命令查看对应类型配置文件的路径\n1  $PROFILE | Get-Member -Type NoteProperty   创建、编辑配置文件 1  notepad $PROFILE   如果配置文件首次设置后, 打开 PowerShell 时显示\n无法加载文件 C:\\Users\\Ma\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1，因为在此系统上禁止运行脚本。\n需要以管理员身份运行以下脚本, 修改执行策略以允许加载配置文件\n1  Set-ExecutionPolicy RemoteSigned   使用配置文件 在 PowerShell 中创建的许多项和运行的大多数命令仅影响当前会话。 结束会话时，将删除这些项。\n特定于会话的命令和项包括添加到会话的 PowerShell 变量、环境变量、别名、函数、命令和 PowerShell 模块。\n若要保存这些项并使其在所有将来的会话中可用，请将它们添加到 PowerShell 配置文件。\n配置文件的另一个常见用途是保存常用函数、别名和变量。 将项目保存在配置文件中时，可以在任何适用的会话中使用它们，而无需重新创建它们。\n导入第三方库 Terminal-Icons 美化终端\n1  Import-Module Terminal-Icons   保存常用函数, 如 将 history 设置为查看所有历史命令, 而非仅仅当前会话的历史命令\n1 2 3 4 5 6 7  # 删除原有的别名 history # PowerShell 5.1版本需使用 Remove-Item 删除 # 更高版本的 PowerShell 可直接使用 Remove-Alias 命令 Remove-Item -Path Alias:history function history{ Get-Content (Get-PSReadlineOption).HistorySavePath -Encoding utf8 }   关于配置文件 - PowerShell | Microsoft Learn\n","date":"2023-04-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/powershell-profile/","title":"PowerShell Profile"},{"content":"多光标操作     ====     Ctrl+I 选中当前行   Shift+Alt+I 将光标插入所选每行的末尾   Ctrl+Shift+L 选择所有与所选中内容相同的内容   Ctrl+F2 选择所有与所选中词汇相同的内容    编辑器控制     ====     Ctrl+\\ 拆分编辑器为多组   Ctrl+ 1 / 2 / 3 切换窗口焦点至某一组    文件管理     ====     Ctrl+K P 复制当前文件路径   Ctrl+K R 打开当前文件所在文件夹    显示     ====     Shift+Alt+0 切换编辑器布局(水平/垂直)   Ctrl+Shift+F 显示搜索界面   Ctrl+Shift+X 显示插件管理界面   Ctrl+K V 预览Markdown文件（侧边）   Ctrl+K Z 禅模式（连按两次Esc退出）    语言操作     ====     Ctrl+K Ctrl+X 移除行尾空白字符    基础编辑     ====     Ctrl+Shift+K 删除行   Ctrl+Enter 在当前行下方插入新行   Ctrl+Shift+Enter 在当前行上方插入新行   Shift+Alt+A 切换块注释   Alt+Z 切换自动换行   Ctrl+K Ctrl+[ 折叠当前所有子代码块   Ctrl+K Ctrl+] 展开当前所有子代码块    ","date":"2023-04-02T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/vscode-keys/","title":"VScode 快捷键"},{"content":"Bookmarklet 是什么 A bookmarklet is a bookmark stored in a web browser that contains JavaScript commands that add new features to the browser. They are stored as the URL of a bookmark in a web browser or as a hyperlink on a web page. Bookmarklets are usually small snippets of JavaScript executed when user clicks on them. When clicked, bookmarklets can perform a wide variety of operations, such as running a search query from selected text or extracting data from a table.\nBookmarklet 可以做什么  浏览器的自动填充功能在部分网站的登录页面不会生效, 点击输入框也不会显示下拉历史记录, 可以使用bookmarklet实现自动输入填充信息登录  1  javascript:(function(){document.querySelector(\u0026#39;#uCode\u0026#39;).value=\u0026#39;username\u0026#39;;document.querySelector(\u0026#39;#pW\u0026#39;).value=\u0026#39;password\u0026#39;;document.querySelector(\u0026#39;#login_btn%20%3E%20button.login\u0026#39;).click();})();    写文章时候, 经常会放上一些摘抄的原网址的标题和链接, 使用下面的bookmarklet可以快速获取文章标题和链接  1  alert(`[${document.title}](${document.URL})`)    上一条改良一下, 直接将markdown格式的链接复制到剪贴板, 免去手动复制  1  navigator.clipboard.writeText(`[${document.title}](${document.URL})`)    再优化一点, 复制成功之后加一个效果(网页标题短暂跳成\u0026quot;Copied!\u0026ldquo;之后又恢复)  1  navigator.clipboard.writeText(`[${document.title}](${document.URL})`);var tt = document.title;document.title=\u0026#34;Copied!\u0026#34;;setTimeout(()=\u0026gt;{document.title=tt}, 1e3)   如何编写 bookmarklet 你只需要编写常规的JavaScript, 网络上有很多在线转换工具, 帮助将常规的js代码生成bookmarklet, 比如:\nBookmarklet Maker\n引用 Bookmarklet - Wikipedia\n阮一峰的 Bookmarklet编写指南\n","date":"2023-03-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/bookmarklet/","title":"Bookmarklet"},{"content":"题目001: 在Python中如何实现单例模式。  点评：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对Python语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。\n 方法一：使用装饰器实现单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from functools import wraps def singleton(cls): \u0026#34;\u0026#34;\u0026#34;单例类装饰器\u0026#34;\u0026#34;\u0026#34; instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President: pass    扩展：装饰器是Python中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的wrapper函数）通常都会用functools模块中的wraps再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个__wrapped__属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用President = President.__wrapped__来取消对President类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在Python中可以使用threading模块的RLock对象来提供锁，可以使用锁对象的acquire和release方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的with上下文语法来进行隐式的加锁和解锁操作。\n 方法二：使用元类实现单例模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class SingletonMeta(type): \u0026#34;\u0026#34;\u0026#34;自定义单例元类\u0026#34;\u0026#34;\u0026#34; def __init__(cls, *args, **kwargs): cls.__instance = None super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): pass    扩展：Python是面向对象的编程语言，在面向对象的世界中，一切皆为对象。对象是通过类来创建的，而类本身也是对象，类这样的对象是通过元类来创建的。我们在定义类时，如果没有给一个类指定父类，那么默认的父类是object，如果没有给一个类指定元类，那么默认的元类是type。通过自定义的元类，我们可以改变一个类默认的行为，就如同上面的代码中，我们通过元类的__call__魔术方法，改变了President类的构造器那样。\n  补充：关于单例模式，在面试中还有可能被问到它的应用场景。通常一个对象的状态是被其他对象共享的，就可以将其设计为单例，例如项目中使用的数据库连接池对象和配置对象通常都是单例，这样才能保证所有地方获取到的数据库连接和配置信息是完全一致的；而且由于对象只有唯一的实例，因此从根本上避免了重复创建对象造成的时间和空间上的开销，也避免了对资源的多重占用。再举个例子，项目中的日志操作通常也会使用单例模式，这是因为共享的日志文件一直处于打开状态，只能有一个实例去操作它，否则在写入日志的时候会产生混乱。\n 题目002：不使用中间变量，交换两个变量a和b的值。  点评：典型的送人头的题目，通常交换两个变量需要借助一个中间变量，如果不允许使用中间变量，在其他编程语言中可以使用异或运算的方式来实现交换两个变量的值，但是Python中有更为简单明了的做法。\n 方法一：\n1 2 3  a = a ^ b b = a ^ b a = a ^ b   方法二：\n1  a, b = b, a    扩展：需要注意，a, b = b, a这种做法其实并不是元组解包，虽然很多人都这样认为。Python字节码指令中有ROT_TWO指令来支持这个操作，类似的还有ROT_THREE，对于3个以上的元素，如a, b, c, d = b, c, d, a，才会用到创建元组和元组解包。想知道你的代码对应的字节码指令，可以使用Python标准库中dis模块的dis函数来反汇编你的Python代码。\n 题目003：写一个删除列表中重复元素的函数，要求去重后元素相对位置保持不变。  点评：这个题目在初中级Python岗位面试的时候经常出现，题目源于《Python Cookbook》这本书第一章的第10个问题，有很多面试题其实都是这本书上的原题，所以建议大家有时间好好研读一下这本书。\n 1 2 3 4 5 6 7 8  def dedup(items): no_dup_items = [] seen = set() for item in items: if item not in seen: no_dup_items.append(item) seen.add(item) return no_dup_items   如果愿意也可以把上面的函数改造成一个生成器，代码如下所示。\n1 2 3 4 5 6  def dedup(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)    扩展：由于Python中的集合底层使用哈希存储，所以集合的in和not in成员运算在性能上远远优于列表，所以上面的代码我们使用了集合来保存已经出现过的元素。集合中的元素必须是hashable对象，因此上面的代码在列表元素不是hashable对象时会失效，要解决这个问题可以给函数增加一个参数，该参数可以设计为返回哈希码或hashable对象的函数。\n 题目004：假设你使用的是官方的CPython，说出下面代码的运行结果。  点评：下面的程序对实际开发并没有什么意义，但却是CPython中的一个大坑，这道题旨在考察面试者对官方的Python解释器到底了解到什么程度。\n 1 2 3 4 5 6 7 8 9 10 11  a, b, c, d = 1, 1, 1000, 1000 print(a is b, c is d) def foo(): e = 1000 f = 1000 print(e is f, e is d) g = 1 print(g is a) foo()   运行结果：\nTrue False True False True 上面代码中a is b的结果是True但c is d的结果是False，这一点的确让人费解。CPython解释器出于性能优化的考虑，把频繁使用的整数对象用一个叫small_ints的对象池缓存起来造成的。small_ints缓存的整数值被设定为[-5, 256]这个区间，也就是说，在任何引用这些整数的地方，都不需要重新创建int对象，而是直接引用缓存池中的对象。如果整数不在该范围内，那么即便两个整数的值相同，它们也是不同的对象。\nCPython底层为了进一步提升性能还做了另一个设定，对于同一个代码块中值不在small_ints缓存范围内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的int对象。需要大家注意的是，这条规则对数值型适用，但对字符串则需要考虑字符串的长度，这一点大家可以自行证明。\n 扩展：如果你用PyPy（另一种Python解释器实现，支持JIT，对CPython的缺点进行了改良，在性能上优于CPython，但对三方库的支持略差）来运行上面的代码，你会发现所有的输出都是True。\n 题目005：Lambda函数是什么，举例说明的它的应用场景。  点评：这个题目主要想考察的是Lambda函数的应用场景，潜台词是问你在项目中有没有使用过Lambda函数，具体在什么场景下会用到Lambda函数，借此来判断你写代码的能力。因为Lambda函数通常用在高阶函数中，主要的作用是通过向函数传入函数或让函数返回函数最终实现代码的解耦合。\n Lambda函数也叫匿名函数，它是功能简单用一行代码就能实现的小型函数。Python中的Lambda函数只能写一个表达式，这个表达式的执行结果就是函数的返回值，不用写return关键字。Lambda函数因为没有名字，所以也不会跟其他函数发生命名冲突的问题。\n 扩展：面试的时候有可能还会考你用Lambda函数来实现一些功能，也就是用一行代码来实现题目要求的功能，例如：用一行代码实现求阶乘的函数，用一行代码实现求最大公约数的函数等。\n      fac = lambda x: import(\u0026lsquo;functools\u0026rsquo;).reduce(int.mul, range(1, x + 1), 1) gcd = lambda x, y: y % x and gcd(y % x, x) or x\n Lambda函数其实最为主要的用途是把一个函数传入另一个高阶函数（如Python内置的`filter`、`map`等）中来为函数做解耦合，增强函数的灵活性和通用性。下面的例子通过使用`filter`和`map`函数，实现了从列表中筛选出奇数并求平方构成新列表的操作，因为用到了高阶函数，过滤和映射数据的规则都是函数的调用者通过另外一个函数传入的，因此这`filter`和`map`函数没有跟特定的过滤和映射数据的规则耦合在一起。 ```python items = [12, 5, 7, 10, 8, 19] items = list(map(lambda x: x ** 2, filter(lambda x: x % 2, items))) print(items) # [25, 49, 361]  扩展：用列表的生成式来实现上面的代码会更加简单明了，代码如下所示。\n      items = [12, 5, 7, 10, 8, 19] items = [x ** 2 for x in items if x % 2] print(items) # [25, 49, 361]\n ## 题目006：说说Python中的浅拷贝和深拷贝。 \u0026gt; **点评**：这个题目本身出现的频率非常高，但是就题论题而言没有什么技术含量。对于这种面试题，在**回答的时候一定要让你的答案能够超出面试官的预期**，这样才能**获得更好的印象分**。所以回答这个题目的要点不仅仅是能够说出浅拷贝和深拷贝的区别，深拷贝的时候可能遇到的两大问题，还要说出Python标准库对浅拷贝和深拷贝的支持，然后可以说说列表、字典如何实现拷贝操作以及如何通过序列化和反序列的方式实现深拷贝，最后还可以提到设计模式中的原型模式以及它在项目中的应用。 浅拷贝通常只复制对象本身，而深拷贝不仅会复制对象，还会递归的复制对象所关联的对象。深拷贝可能会遇到两个问题：一是一个对象如果直接或间接的引用了自身，会导致无休止的递归拷贝；二是深拷贝可能对原本设计为多个对象共享的数据也进行拷贝。Python通过`copy`模块中的`copy`和`deepcopy`函数来实现浅拷贝和深拷贝操作，其中`deepcopy`可以通过`memo`字典来保存已经拷贝过的对象，从而避免刚才所说的自引用递归问题；此外，可以通过`copyreg`模块的`pickle`函数来定制指定类型对象的拷贝行为。 `deepcopy`函数的本质其实就是对象的一次序列化和一次返回序列化，面试题中还考过用自定义函数实现对象的深拷贝操作，显然我们可以使用`pickle`模块的`dumps`和`loads`来做到，代码如下所示。 ```python import pickle my_deep_copy = lambda obj: pickle.loads(pickle.dumps(obj)) 列表的切片操作[:]相当于实现了列表对象的浅拷贝，而字典的copy方法可以实现字典对象的浅拷贝。对象拷贝其实是更为快捷的创建对象的方式。在Python中，通过构造器创建对象属于两阶段构造，首先是分配内存空间，然后是初始化。在创建对象时，我们也可以基于“原型”对象来创建新对象，通过对原型对象的拷贝（复制内存）就完成了对象的创建和初始化，这种做法更加高效，这也就是设计模式中的原型模式。在Python中，我们可以通过元类的方式来实现原型模式，代码如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import copy class PrototypeMeta(type): \u0026#34;\u0026#34;\u0026#34;实现原型模式的元类\u0026#34;\u0026#34;\u0026#34; def __init__(cls, *args, **kwargs): super().__init__(*args, **kwargs) # 为对象绑定clone方法来实现对象拷贝 cls.clone = lambda self, is_deep=True: \\ copy.deepcopy(self) if is_deep else copy.copy(self) class Person(metaclass=PrototypeMeta): pass p1 = Person() p2 = p1.clone() # 深拷贝 p3 = p1.clone(is_deep=False) # 浅拷贝   题目007：Python是如何实现内存管理的？  点评：当面试官问到这个问题的时候，一个展示自己的机会就摆在面前了。你要先反问面试官：“你说的是官方的CPython解释器吗？”。这个反问可以展示出你了解过Python解释器的不同的实现版本，而且你也知道面试官想问的是CPython。当然，很多面试官对不同的Python解释器底层实现到底有什么差别也没有概念。所以，千万不要觉得面试官一定比你强，怀揣着这份自信可以让你更好的完成面试。\n Python提供了自动化的内存管理，也就是说内存空间的分配与释放都是由Python解释器在运行时自动进行的，自动管理内存功能极大的减轻程序员的工作负担，也能够帮助程序员在一定程度上解决内存泄露的问题。以CPython解释器为例，它的内存管理有三个关键点：引用计数、标记清理、分代收集。\n引用计数：对于CPython解释器来说，Python中的每一个对象其实就是PyObject结构体，它的内部有一个名为ob_refcnt 的引用计数器成员变量。程序在运行的过程中ob_refcnt的值会被更新并藉此来反映引用有多少个变量引用到该对象。当对象的引用计数值为0时，它的内存就会被释放掉。\n1 2 3 4 5  typedef struct _object { _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type; } PyObject;   以下情况会导致引用计数加1：\n 对象被创建 对象被引用 对象作为参数传入到一个函数中 对象作为元素存储到一个容器中  以下情况会导致引用计数减1：\n 用del语句显示删除对象引用 对象引用被重新赋值其他对象 一个对象离开它所在的作用域 持有该对象的容器自身被销毁 持有该对象的容器删除该对象  可以通过sys模块的getrefcount函数来获得对象的引用计数。引用计数的内存管理方式在遇到循环引用的时候就会出现致命伤，因此需要其他的垃圾回收算法对其进行补充。\n标记清理：CPython使用了“标记-清理”（Mark and Sweep）算法解决容器类型可能产生的循环引用问题。该算法在垃圾回收时分为两个阶段：标记阶段，遍历所有的对象，如果对象是可达的（被其他对象引用），那么就标记该对象为可达；清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。CPython底层维护了两个双端链表，一个链表存放着需要被扫描的容器对象（姑且称之为链表A），另一个链表存放着临时不可达对象（姑且称之为链表B）。为了实现“标记-清理”算法，链表中的每个节点除了有记录当前引用计数的ref_count变量外，还有一个gc_ref变量，这个gc_ref是ref_count的一个副本，所以初始值为ref_count的大小。执行垃圾回收时，首先遍历链表A中的节点，并且将当前对象所引用的所有对象的gc_ref减1，这一步主要作用是解除循环引用对引用计数的影响。再次遍历链表A中的节点，如果节点的gc_ref值为0，那么这个对象就被标记为“暂时不可达”（GC_TENTATIVELY_UNREACHABLE）并被移动到链表B中；如果节点的gc_ref不为0，那么这个对象就会被标记为“可达“（GC_REACHABLE），对于”可达“对象，还要递归的将该节点可以到达的节点标记为”可达“；链表B中被标记为”可达“的节点要重新放回到链表A中。在两次遍历之后，链表B中的节点就是需要释放内存的节点。\n分代回收：在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过分代回收（空间换时间）的方法提高垃圾回收效率。分代回收的基本思想是：对象存在的时间越长，是垃圾的可能性就越小，应该尽量不对这样的对象进行垃圾回收。CPython将对象分为三种世代分别记为0、1、2，每一个新生对象都在第0代中，如果该对象在一轮垃圾回收扫描中存活下来，那么它将被移到第1代中，存在于第1代的对象将较少的被垃圾回收扫描到；如果在对第1代进行垃圾回收扫描时，这个对象又存活下来，那么它将被移至第2代中，在那里它被垃圾回收扫描的次数将会更少。分代回收扫描的门限值可以通过gc模块的get_threshold函数来获得，该函数返回一个三元组，分别表示多少次内存分配操作后会执行0代垃圾回收，多少次0代垃圾回收后会执行1代垃圾回收，多少次1代垃圾回收后会执行2代垃圾回收。需要说明的是，如果执行一次2代垃圾回收，那么比它年轻的代都要执行垃圾回收。如果想修改这几个门限值，可以通过gc模块的set_threshold函数来做到。\n题目008：说一下你对Python中迭代器和生成器的理解。  点评：很多人面试者都会写迭代器和生成器，但是却无法准确的解释什么是迭代器和生成器。如果你也有同样的困惑，可以参考下面的回答。\n 迭代器是实现了迭代器协议的对象。跟其他编程语言不通，Python中没有用于定义协议或表示约定的关键字，像interface、protocol这些单词并不在Python语言的关键字列表中。Python语言通过魔法方法来表示约定，也就是我们所说的协议，而__next__和__iter__这两个魔法方法就代表了迭代器协议。可以通过for-in循环从迭代器对象中取出值，也可以使用next函数取出迭代器对象中的下一个值。生成器是迭代器的语法升级版本，可以用更为简单的代码来实现一个迭代器。\n 扩展：面试中经常让写生成斐波那契数列的迭代器，大家可以参考下面的代码。\n      class Fib(object):\ndef __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx \u0026lt; self.num: self.a, self.b = self.b, self.a + self.b self.idx += 1 return self.a raise StopIteration()   \u0026gt; 如果用生成器的语法来改写上面的代码，代码会简单优雅很多。 \u0026gt; ```python def fib(num): a, b = 0, 1 for _ in range(num): a, b = b, a + b yield a 题目009：正则表达式的match方法和search方法有什么区别？  点评：正则表达式是字符串处理的重要工具，所以也是面试中经常考察的知识点。在Python中，使用正则表达式有两种方式，一种是直接调用re模块中的函数，传入正则表达式和需要处理的字符串；一种是先通过re模块的compile函数创建正则表达式对象，然后再通过对象调用方法并传入需要处理的字符串。如果一个正则表达式被频繁的使用，我们推荐用re.compile函数创建正则表达式对象，这样会减少频繁编译同一个正则表达式所造成的开销。\n match方法是从字符串的起始位置进行正则表达式匹配，返回Match对象或None。search方法会扫描整个字符串来找寻匹配的模式，同样也是返回Match对象或None。\n题目010：下面这段代码的执行结果是什么。 1 2 3 4  def multiply(): return [lambda x: i * x for i in range(4)] print([m(100) for m in multiply()])   运行结果：\n[300, 300, 300, 300] 上面代码的运行结果很容易被误判为[0, 100, 200, 300]。首先需要注意的是multiply函数用生成式语法返回了一个列表，列表中保存了4个Lambda函数，这4个Lambda函数会返回传入的参数乘以i的结果。需要注意的是这里有闭包（closure）现象，multiply函数中的局部变量i的生命周期被延展了，由于i最终的值是3，所以通过m(100)调列表中的Lambda函数时会返回300，而且4个调用都是如此。\n如果想得到[0, 100, 200, 300]这个结果，可以按照下面几种方式来修改multiply函数。\n方法一：使用生成器，让函数获得i的当前值。\n1 2 3 4  def multiply(): return (lambda x: i * x for i in range(4)) print([m(100) for m in multiply()])   或者\n1 2 3 4 5  def multiply(): for i in range(4): yield lambda x: x * i print([m(100) for m in multiply()])   方法二：使用偏函数，彻底避开闭包。\n1 2 3 4 5 6 7  from functools import partial from operator import __mul__ def multiply(): return [partial(__mul__, i) for i in range(4)] print([m(100) for m in multiply()])   题目011：Python中为什么没有函数重载？  点评：C++、Java、C#等诸多编程语言都支持函数重载，所谓函数重载指的是在同一个作用域中有多个同名函数，它们拥有不同的参数列表（参数个数不同或参数类型不同或二者皆不同），可以相互区分。重载也是一种多态性，因为通常是在编译时通过参数的个数和类型来确定到底调用哪个重载函数，所以也被称为编译时多态性或者叫前绑定。这个问题的潜台词其实是问面试者是否有其他编程语言的经验，是否理解Python是动态类型语言，是否知道Python中函数的可变参数、关键字参数这些概念。\n 首先Python是解释型语言，函数重载现象通常出现在编译型语言中。其次Python是动态类型语言，函数的参数没有类型约束，也就无法根据参数类型来区分重载。再者Python中函数的参数可以有默认值，可以使用可变参数和关键字参数，因此即便没有函数重载，也要可以让一个函数根据调用者传入的参数产生不同的行为。\n题目012：用Python代码实现Python内置函数max。  点评：这个题目看似简单，但实际上还是比较考察面试者的功底。因为Python内置的max函数既可以传入可迭代对象找出最大，又可以传入两个或多个参数找出最大；最为关键的是还可以通过命名关键字参数key来指定一个用于元素比较的函数，还可以通过default命名关键字参数来指定当可迭代对象为空时返回的默认值。\n 下面的代码仅供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def my_max(*args, key=None, default=None): \u0026#34;\u0026#34;\u0026#34; 获取可迭代对象中最大的元素或两个及以上实参中最大的元素 :param args: 一个可迭代对象或多个元素 :param key: 提取用于元素比较的特征值的函数，默认为None :param default: 如果可迭代对象为空则返回该默认值，如果没有给默认值则引发ValueError异常 :return: 返回可迭代对象或多个元素中的最大元素 \u0026#34;\u0026#34;\u0026#34; if len(args) == 1 and len(args[0]) == 0: if default: return default else: raise ValueError(\u0026#39;max() arg is an empty sequence\u0026#39;) items = args[0] if len(args) == 1 else args max_elem, max_value = items[0], items[0] if key: max_value = key(max_value) for item in items: value = item if key: value = key(item) if value \u0026gt; max_value: max_elem, max_value = item, value return max_elem   题目013：写一个函数统计传入的列表中每个数字出现的次数并返回对应的字典。  点评：送人头的题目，不解释。\n 1 2 3 4 5 6  def count_letters(items): result = {} for item in items: if isinstance(item, (int, float)): result[item] = result.get(item, 0) + 1 return result   也可以直接使用Python标准库中collections模块的Counter类来解决这个问题，Counter是dict的子类，它会将传入的序列中的每个元素作为键，元素出现的次数作为值来构造字典。\n1 2 3 4 5 6  from collections import Counter def count_letters(items): counter = Counter(items) return {key: value for key, value in counter.items() \\ if isinstance(key, (int, float))}   题目014：使用Python代码实现遍历一个文件夹的操作。  点评：基本也是送人头的题目，只要用过os模块就应该知道怎么做。\n Python标准库os模块的walk函数提供了遍历一个文件夹的功能，它返回一个生成器。\n1 2 3 4 5 6 7 8  import os g = os.walk(\u0026#39;/Users/Hao/Downloads/\u0026#39;) for path, dir_list, file_list in g: for dir_name in dir_list: print(os.path.join(path, dir_name)) for file_name in file_list: print(os.path.join(path, file_name))    说明：os.path模块提供了很多进行路径操作的工具函数，在项目开发中也是经常会用到的。如果题目明确要求不能使用os.walk函数，那么可以使用os.listdir函数来获取指定目录下的文件和文件夹，然后再通过循环遍历用os.isdir函数判断哪些是文件夹，对于文件夹可以通过递归调用进行遍历，这样也可以实现遍历一个文件夹的操作。\n 题目015：现有2元、3元、5元共三种面额的货币，如果需要找零99元，一共有多少种找零的方式？  点评：还有一个非常类似的题目：“一个小朋友走楼梯，一次可以走1个台阶、2个台阶或3个台阶，问走完10个台阶一共有多少种走法？”，这两个题目的思路是一样，如果用递归函数来写的话非常简单。\n 1 2 3 4 5 6 7 8 9 10 11  from functools import lru_cache @lru_cache() def change_money(total): if total == 0: return 1 if total \u0026lt; 0: return 0 return change_money(total - 2) + change_money(total - 3) + \\ change_money(total - 5)    说明：在上面的代码中，我们用lru_cache装饰器装饰了递归函数change_money，如果不做这个优化，上面代码的渐近时间复杂度将会是$O(3^N)$，而如果参数total的值是99，这个运算量是非常巨大的。lru_cache装饰器会缓存函数的执行结果，这样就可以减少重复运算所造成的开销，这是空间换时间的策略，也是动态规划的编程思想。\n 题目016：写一个函数，给定矩阵的阶数n，输出一个螺旋式数字矩阵。  例如：n = 2，返回：\n   1 2 4 3\n \u0026gt; 例如：n = 3，返回： \u0026gt; ``` 1 2 3 8 9 4 7 6 5 这个题目本身并不复杂，下面的代码仅供参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  def show_spiral_matrix(n): matrix = [[0] * n for _ in range(n)] row, col = 0, 0 num, direction = 1, 0 while num \u0026lt;= n ** 2: if matrix[row][col] == 0: matrix[row][col] = num num += 1 if direction == 0: if col \u0026lt; n - 1 and matrix[row][col + 1] == 0: col += 1 else: direction += 1 elif direction == 1: if row \u0026lt; n - 1 and matrix[row + 1][col] == 0: row += 1 else: direction += 1 elif direction == 2: if col \u0026gt; 0 and matrix[row][col - 1] == 0: col -= 1 else: direction += 1 else: if row \u0026gt; 0 and matrix[row - 1][col] == 0: row -= 1 else: direction += 1 direction %= 4 for x in matrix: for y in x: print(y, end=\u0026#39;\\t\u0026#39;) print()   题目017：阅读下面的代码，写出程序的运行结果。 1 2 3 4 5 6  items = [1, 2, 3, 4] print([i for i in items if i \u0026gt; 2]) print([i for i in items if i % 2]) print([(x, y) for x, y in zip(\u0026#39;abcd\u0026#39;, (1, 2, 3, 4, 5))]) print({x: f\u0026#39;item{x ** 2}\u0026#39; for x in (2, 4, 6)}) print(len({x for x in \u0026#39;hello world\u0026#39; if x not in \u0026#39;abcdefg\u0026#39;}))    点评：生成式（推导式）属于Python的特色语法之一，几乎是面试必考内容。Python中通过生成式字面量语法，可以创建出列表、集合、字典。\n [3, 4] [1, 3] [('a', 1), ('b', 2), ('c', 3), ('d', 4)] {2: 'item4', 4: 'item16', 6: 'item36'} 6 题目018：说出下面代码的运行结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Parent: x = 1 class Child1(Parent): pass class Child2(Parent): pass print(Parent.x, Child1.x, Child2.x) Child1.x = 2 print(Parent.x, Child1.x, Child2.x) Parent.x = 3 print(Parent.x, Child1.x, Child2.x)    点评：运行上面的代码首先输出1 1 1，这一点大家应该没有什么疑问。接下来，通过Child1.x = 2给类Child1重新绑定了属性x并赋值为2，所以Child1.x会输出2，而Parent和Child2并不受影响。执行Parent.x = 3会重新给Parent类的x属性赋值为3，由于Child2的x属性继承自Parent，所以Child2.x的值也是3；而之前我们为Child1重新绑定了x属性，那么它的x属性值不会受到Parent.x = 3的影响，还是之前的值2。\n 1 1 1 1 2 1 3 2 3 题目19：说说你用过Python标准库中的哪些模块。  点评：Python标准库中的模块非常多，建议大家根据自己过往的项目经历来介绍你用过的标准库和三方库，因为这些是你最为熟悉的，经得起面试官深挖的。\n    模块名 介绍     sys 跟Python解释器相关的变量和函数，例如：sys.version、sys.exit()   os 和操作系统相关的功能，例如：os.listdir()、os.remove()   re 和正则表达式相关的功能，例如：re.compile()、re.search()   math 和数学运算相关的功能，例如：math.pi、math.e、math.cos   logging 和日志系统相关的类和函数，例如：logging.Logger、logging.Handler   json / pickle 实现对象序列化和反序列的模块，例如：json.loads、json.dumps   hashlib 封装了多种哈希摘要算法的模块，例如：hashlib.md5、hashlib.sha1   urllib 包含了和URL相关的子模块，例如：urllib.request、urllib.parse   itertools 提供各种迭代器的模块，例如：itertools.cycle、itertools.product   functools 函数相关工具模块，例如：functools.partial、functools.lru_cache   collections / heapq 封装了常用数据结构和算法的模块，例如：collections.deque   threading / multiprocessing 多线程/多进程相关类和函数的模块，例如：threading.Thread   concurrent.futures / asyncio 并发编程/异步编程相关的类和函数的模块，例如：ThreadPoolExecutor   base64 提供BASE-64编码相关函数的模块，例如：bas64.encode   csv 和读写CSV文件相关的模块，例如：csv.reader、csv.writer   profile / cProfile / pstats 和代码性能剖析相关的模块，例如：cProfile.run、pstats.Stats   unittest 和单元测试相关的模块，例如：unittest.TestCase    题目20：__init__和__new__方法有什么区别？ Python中调用构造器创建对象属于两阶段构造过程，首先执行__new__方法获得保存对象所需的内存空间，再通过__init__执行对内存空间数据的填充（对象属性的初始化）。__new__方法的返回值是创建好的Python对象（的引用），而__init__方法的第一个参数就是这个对象（的引用），所以在__init__中可以完成对对象的初始化操作。__new__是类方法，它的第一个参数是类，__init__是对象方法，它的第一个参数是对象。\n题目21：输入年月日，判断这个日期是这一年的第几天。 方法一：不使用标准库中的模块和函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13  def is_leap_year(year): \u0026#34;\u0026#34;\u0026#34;判断指定的年份是不是闰年，平年返回False，闰年返回True\u0026#34;\u0026#34;\u0026#34; return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): \u0026#34;\u0026#34;\u0026#34;计算传入的日期是这一年的第几天\u0026#34;\u0026#34;\u0026#34; # 用嵌套的列表保存平年和闰年每个月的天数 days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ] days = days_of_month[is_leap_year(year)][:month - 1] return sum(days) + date   方法二：使用标准库中的datetime模块。\n1 2 3 4 5 6  import datetime def which_day(year, month, date): end = datetime.date(year, month, date) start = datetime.date(year, 1, 1) return (end - start).days + 1   题目22：平常工作中用什么工具进行静态代码分析。  点评：静态代码分析工具可以从代码中提炼出各种静态属性，这使得开发者可以对代码的复杂性、可维护性和可读性有更好的了解，这里所说的静态属性包括：\n   代码是否符合编码规范，例如：PEP-8。 代码中潜在的问题，包括：语法错误、缩进问题、导入缺失、变量覆盖等。 代码中的坏味道。 代码的复杂度。 代码的逻辑问题。   工作中静态代码分析主要用到的是Pylint和Flake8。Pylint可以检查出代码错误、坏味道、不规范的代码等问题，较新的版本中还提供了代码复杂度统计数据，可以生成检查报告。Flake8封装了Pyflakes（检查代码逻辑错误）、McCabe（检查代码复杂性）和Pycodestyle（检查代码是否符合PEP-8规范）工具，它可以执行这三个工具提供的检查。\n题目23：说一下你知道的Python中的魔术方法。  点评：魔术方法也称为魔法方法，是Python中的特色语法，也是面试中的高频问题。\n    魔术方法 作用     __new__、__init__、__del__ 创建和销毁对象相关   __add__、__sub__、__mul__、__div__、__floordiv__、__mod__ 算术运算符相关   __eq__、__ne__、__lt__、__gt__、__le__、__ge__ 关系运算符相关   __pos__、__neg__、__invert__ 一元运算符相关   __lshift__、__rshift__、__and__、__or__、__xor__ 位运算相关   __enter__、__exit__ 上下文管理器协议   __iter__、__next__、__reversed__ 迭代器协议   __int__、__long__、__float__、__oct__、__hex__ 类型/进制转换相关   __str__、__repr__、__hash__、__dir__ 对象表述相关   __len__、__getitem__、__setitem__、__contains__、__missing__ 序列相关   __copy__、__deepcopy__ 对象拷贝相关   __call__、__setattr__、__getattr__、__delattr__ 其他魔术方法    题目24：函数参数*arg和**kwargs分别代表什么？ Python中，函数的参数分为位置参数、可变参数、关键字参数、命名关键字参数。*args代表可变参数，可以接收0个或任意多个参数，当不确定调用者会传入多少个位置参数时，就可以使用可变参数，它会将传入的参数打包成一个元组。**kwargs代表关键字参数，可以接收用参数名=参数值的方式传入的参数，传入的参数的会打包成一个字典。定义函数时如果同时使用*args和**kwargs，那么函数可以接收任意参数。\n题目25：写一个记录函数执行时间的装饰器。  点评：高频面试题，也是最简单的装饰器，面试者必须要掌握的内容。\n 方法一：用函数实现装饰器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  from functools import wraps from time import time def record_time(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) print(f\u0026#39;{func.__name__}执行时间: {time() - start}秒\u0026#39;) return result return wrapper   方法二：用类实现装饰器。类有__call__魔术方法，该类对象就是可调用对象，可以当做装饰器来使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from functools import wraps from time import time class Record: def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) print(f\u0026#39;{func.__name__}执行时间: {time() - start}秒\u0026#39;) return result return wrapper    说明：装饰器可以用来装饰类或函数，为其提供额外的能力，属于设计模式中的代理模式。\n  扩展：装饰器本身也可以参数化，例如上面的例子中，如果不希望在终端中显示函数的执行时间而是希望由调用者来决定如何输出函数的执行时间，可以通过参数化装饰器的方式来做到，代码如下所示。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from functools import wraps from time import time def record_time(output): \u0026#34;\u0026#34;\u0026#34;可以参数化的装饰器\u0026#34;\u0026#34;\u0026#34; def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapper return decorate   题目26：什么是鸭子类型（duck typing）？ 鸭子类型是动态类型语言判断一个对象是不是某种类型时使用的方法，也叫做鸭子判定法。简单的说，鸭子类型是指判断一只鸟是不是鸭子，我们只关心它游泳像不像鸭子、叫起来像不像鸭子、走路像不像鸭子就足够了。换言之，如果对象的行为跟我们的预期是一致的（能够接受某些消息），我们就认定它是某种类型的对象。\n在Python语言中，有很多bytes-like对象（如：bytes、bytearray、array.array、memoryview）、file-like对象（如：StringIO、BytesIO、GzipFile、socket）、path-like对象（如：str、bytes），其中file-like对象都能支持read和write操作，可以像文件一样读写，这就是所谓的对象有鸭子的行为就可以判定为鸭子的判定方法。再比如Python中列表的extend方法，它需要的参数并不一定要是列表，只要是可迭代对象就没有问题。\n 说明：动态语言的鸭子类型使得设计模式的应用被大大简化。\n 题目27：说一下Python中变量的作用域。 Python中有四种作用域，分别是局部作用域（Local）、嵌套作用域（Embedded）、全局作用域（Global）、内置作用域（Built-in），搜索一个标识符时，会按照LEGB的顺序进行搜索，如果所有的作用域中都没有找到这个标识符，就会引发NameError异常。\n题目28：说一下你对闭包的理解。 闭包是支持一等函数的编程语言（Python、JavaScript等）中实现词法绑定的一种技术。当捕捉闭包的时候，它的自由变量（在函数外部定义但在函数内部使用的变量）会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。简单的说，可以将闭包理解为能够读取其他函数内部变量的函数。正在情况下，函数的局部变量在函数调用结束之后就结束了生命周期，但是闭包使得局部变量的生命周期得到了延展。使用闭包的时候需要注意，闭包会使得函数中创建的对象不会被垃圾回收，可能会导致很大的内存开销，所以闭包一定不能滥用。\n题目29：说一下Python中的多线程和多进程的应用场景和优缺点。 线程是操作系统分配CPU的基本单位，进程是操作系统分配内存的基本单位。通常我们运行的程序会包含一个或多个进程，而每个进程中又包含一个或多个线程。多线程的优点在于多个线程可以共享进程的内存空间，所以进程间的通信非常容易实现；但是如果使用官方的CPython解释器，多线程受制于GIL（全局解释器锁），并不能利用CPU的多核特性，这是一个很大的问题。使用多进程可以充分利用CPU的多核特性，但是进程间通信相对比较麻烦，需要使用IPC机制（管道、套接字等）。\n多线程适合那些会花费大量时间在I/O操作上，但没有太多并行计算需求且不需占用太多内存的I/O密集型应用。多进程适合执行计算密集型任务（如：视频编码解码、数据处理、科学计算等）、可以分解为多个并行子任务并能合并子任务执行结果的任务以及在内存使用方面没有任何限制且不强依赖于I/O操作的任务。\n 扩展：Python中实现并发编程通常有多线程、多进程和异步编程三种选择。异步编程实现了协作式并发，通过多个相互协作的子程序的用户态切换，实现对CPU的高效利用，这种方式也是非常适合I/O密集型应用的。\n 题目30：说一下Python 2和Python 3的区别。  点评：这种问题千万不要背所谓的参考答案，说一些自己最熟悉的就足够了。\n  Python 2中的print和exec都是关键字，在Python 3中变成了函数。 Python 3中没有long类型，整数都是int类型。 Python 2中的不等号\u0026lt;\u0026gt;在Python 3中被废弃，统一使用!=。 Python 2中的xrange函数在Python 3中被range函数取代。 Python 3对Python 2中不安全的input函数做出了改进，废弃了raw_input函数。 Python 2中的file函数被Python 3中的open函数取代。 Python 2中的/运算对于int类型是整除，在Python 3中要用//来做整除除法。 Python 3中改进了Python 2捕获异常的代码，很明显Python 3的写法更合理。 Python 3生成式中循环变量的作用域得到了更好的控制，不会影响到生成式之外的同名变量。 Python 3中的round函数可以返回int或float类型，Python 2中的round函数返回float类型。 Python 3的str类型是Unicode字符串，Python 2的str类型是字节串，相当于Python 3中的bytes。 Python 3中的比较运算符必须比较同类对象。 Python 3中定义类的都是新式类，Python 2中定义的类有新式类（显式继承自object的类）和旧式类（经典类）之分，新式类和旧式类在MRO问题上有非常显著的区别，新式类可以使用__class__属性获取自身类型，新式类可以使用__slots__魔法。 Python 3对代码缩进的要求更加严格，如果混用空格和制表键会引发TabError。 Python 3中字典的keys、values、items方法都不再返回list对象，而是返回view object，内置的map、filter等函数也不再返回list对象，而是返回迭代器对象。 Python 3标准库中某些模块的名字跟Python 2是有区别的；而在三方库方面，有些三方库只支持Python 2，有些只能支持Python 3。  题目31：谈谈你对“猴子补丁”（monkey patching）的理解。 “猴子补丁”是动态类型语言的一个特性，代码运行时在不修改源代码的前提下改变代码中的方法、属性、函数等以达到热补丁（hot patch）的效果。很多系统的安全补丁也是通过猴子补丁的方式来实现的，但实际开发中应该避免对猴子补丁的使用，以免造成代码行为不一致的问题。\n在使用gevent库的时候，我们会在代码开头的地方执行gevent.monkey.patch_all()，这行代码的作用是把标准库中的socket模块给替换掉，这样我们在使用socket的时候，不用修改任何代码就可以实现对代码的协程化，达到提升性能的目的，这就是对猴子补丁的应用。\n另外，如果希望用ujson三方库替换掉标准库中的json，也可以使用猴子补丁的方式，代码如下所示。\n1 2 3 4 5  import json, ujson json.__name__ = \u0026#39;ujson\u0026#39; json.dumps = ujson.dumps json.loads = ujson.loads   单元测试中的Mock技术也是对猴子补丁的应用，Python中的unittest.mock模块就是解决单元测试中用Mock对象替代被测对象所依赖的对象的模块。\n题目32：阅读下面的代码说出运行结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class A: def who(self): print(\u0026#39;A\u0026#39;, end=\u0026#39;\u0026#39;) class B(A): def who(self): super(B, self).who() print(\u0026#39;B\u0026#39;, end=\u0026#39;\u0026#39;) class C(A): def who(self): super(C, self).who() print(\u0026#39;C\u0026#39;, end=\u0026#39;\u0026#39;) class D(B, C): def who(self): super(D, self).who() print(\u0026#39;D\u0026#39;, end=\u0026#39;\u0026#39;) item = D() item.who()    点评：这道题考查到了两个知识点：\n   Python中的MRO（方法解析顺序）。在没有多重继承的情况下，向对象发出一个消息，如果对象没有对应的方法，那么向上（父类）搜索的顺序是非常清晰的。如果向上追溯到object类（所有类的父类）都没有找到对应的方法，那么将会引发AttributeError异常。但是有多重继承尤其是出现菱形继承（钻石继承）的时候，向上追溯到底应该找到那个方法就得确定MRO。Python 3中的类以及Python 2中的新式类使用C3算法来确定MRO，它是一种类似于广度优先搜索的方法；Python 2中的旧式类（经典类）使用深度优先搜索来确定MRO。在搞不清楚MRO的情况下，可以使用类的mro方法或__mro__属性来获得类的MRO列表。 super()函数的使用。在使用super函数时，可以通过super(类型, 对象)来指定对哪个对象以哪个类为起点向上搜索父类方法。所以上面B类代码中的super(B, self).who()表示以B类为起点，向上搜索self（D类对象）的who方法，所以会找到C类中的who方法，因为D类对象的MRO列表是D --\u0026gt; B --\u0026gt; C --\u0026gt; A --\u0026gt; object。   ACBD 题目33：编写一个函数实现对逆波兰表达式求值，不能使用Python的内置函数。  点评：逆波兰表达式也称为“后缀表达式”，相较于平常我们使用的“中缀表达式”，逆波兰表达式不需要括号来确定运算的优先级，例如5 * (2 + 3)对应的逆波兰表达式是5 2 3 + *。逆波兰表达式求值需要借助栈结构，扫描表达式遇到运算数就入栈，遇到运算符就出栈两个元素做运算，将运算结果入栈。表达式扫描结束后，栈中只有一个数，这个数就是最终的运算结果，直接出栈即可。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import operator class Stack: \u0026#34;\u0026#34;\u0026#34;栈（FILO）\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.elems = [] def push(self, elem): \u0026#34;\u0026#34;\u0026#34;入栈\u0026#34;\u0026#34;\u0026#34; self.elems.append(elem) def pop(self): \u0026#34;\u0026#34;\u0026#34;出栈\u0026#34;\u0026#34;\u0026#34; return self.elems.pop() @property def is_empty(self): \u0026#34;\u0026#34;\u0026#34;检查栈是否为空\u0026#34;\u0026#34;\u0026#34; return len(self.elems) == 0 def eval_suffix(expr): \u0026#34;\u0026#34;\u0026#34;逆波兰表达式求值\u0026#34;\u0026#34;\u0026#34; operators = { \u0026#39;+\u0026#39;: operator.add, \u0026#39;-\u0026#39;: operator.sub, \u0026#39;*\u0026#39;: operator.mul, \u0026#39;/\u0026#39;: operator.truediv } stack = Stack() for item in expr.split(): if item.isdigit(): stack.push(float(item)) else: num2 = stack.pop() num1 = stack.pop() stack.push(operators[item](num1, num2)) return stack.pop()   题目34：Python中如何实现字符串替换操作？ Python中实现字符串替换大致有两类方法：字符串的replace方法和正则表达式的sub方法。\n方法一：使用字符串的replace方法。\n1 2  message = \u0026#39;hello, world!\u0026#39; print(message.replace(\u0026#39;o\u0026#39;, \u0026#39;O\u0026#39;).replace(\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;).replace(\u0026#39;he\u0026#39;, \u0026#39;HE\u0026#39;))   方法二：使用正则表达式的sub方法。\n1 2 3 4 5  import re message = \u0026#39;hello, world!\u0026#39; pattern = re.compile(\u0026#39;[aeiou]\u0026#39;) print(pattern.sub(\u0026#39;#\u0026#39;, message))    扩展：还有一个相关的面试题，对保存文件名的列表排序，要求文件名按照字母表和数字大小进行排序，例如对于列表filenames = ['a12.txt', 'a8.txt', 'b10.txt', 'b2.txt', 'b19.txt', 'a3.txt']，排序的结果是['a3.txt', 'a8.txt', 'a12.txt', 'b2.txt', 'b10.txt', 'b19.txt']。提示一下，可以通过字符串替换的方式为文件名补位，根据补位后的文件名用sorted函数来排序，大家可以思考下这个问题如何解决。\n 题目35：如何剖析Python代码的执行性能？ 剖析代码性能可以使用Python标准库中的cProfile和pstats模块，cProfile的run函数可以执行代码并收集统计信息，创建出Stats对象并打印简单的剖析报告。Stats是pstats模块中的类，它是一个统计对象。当然，也可以使用三方工具line_profiler和memory_profiler来剖析每一行代码耗费的时间和内存，这两个三方工具都会用非常友好的方式输出剖析结构。如果使用PyCharm，可以利用“Run”菜单的“Profile”菜单项对代码进行性能分析，PyCharm中可以用表格或者调用图（Call Graph）的方式来显示性能剖析的结果。\n下面是使用cProfile剖析代码性能的例子。\nexample.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import cProfile def is_prime(num): for factor in range(2, int(num ** 0.5) + 1): if num % factor == 0: return False return True class PrimeIter: def __init__(self, total): self.counter = 0 self.current = 1 self.total = total def __iter__(self): return self def __next__(self): if self.counter \u0026lt; self.total: self.current += 1 while not is_prime(self.current): self.current += 1 self.counter += 1 return self.current raise StopIteration() cProfile.run(\u0026#39;list(PrimeIter(10000))\u0026#39;)   如果使用line_profiler三方工具，可以直接剖析is_prime函数每行代码的性能，需要给is_prime函数添加一个profiler装饰器，代码如下所示。\n1 2 3 4 5 6  @profiler def is_prime(num): for factor in range(2, int(num ** 0.5) + 1): if num % factor == 0: return False return True   安装line_profiler。\n1  pip install line_profiler   使用line_profiler。\n1  kernprof -lv example.py   运行结果如下所示。\nLine # Hits Time Per Hit % Time Line Contents ============================================================== 1 @profile 2 def is_prime(num): 3 86624 48420.0 0.6 50.5 for factor in range(2, int(num ** 0.5) + 1): 4 85624 44000.0 0.5 45.9 if num % factor == 0: 5 6918 3080.0 0.4 3.2 return False 6 1000 430.0 0.4 0.4 return True 题目36：如何使用random模块生成随机数、实现随机乱序和随机抽样？  点评：送人头的题目，因为Python标准库中的常用模块应该是Python开发者都比较熟悉的内容，这个问题回如果答不上来，整个面试基本也就砸锅了。\n  random.random()函数可以生成[0.0, 1.0)之间的随机浮点数。 random.uniform(a, b)函数可以生成[a, b]或[b, a]之间的随机浮点数。 random.randint(a, b)函数可以生成[a, b]或[b, a]之间的随机整数。 random.shuffle(x)函数可以实现对序列x的原地随机乱序。 random.choice(seq)函数可以从非空序列中取出一个随机元素。 random.choices(population, weights=None, *, cum_weights=None, k=1)函数可以从总体中随机抽取（有放回抽样）出容量为k的样本并返回样本的列表，可以通过参数指定个体的权重，如果没有指定权重，个体被选中的概率均等。 random.sample(population, k)函数可以从总体中随机抽取（无放回抽样）出容量为k的样本并返回样本的列表。   扩展：random模块提供的函数除了生成均匀分布的随机数外，还可以生成其他分布的随机数，例如random.gauss(mu, sigma)函数可以生成高斯分布（正态分布）的随机数；random.paretovariate(alpha)函数会生成帕累托分布的随机数；random.gammavariate(alpha, beta)函数会生成伽马分布的随机数。\n 题目37：解释一下线程池的工作原理。  点评：池化技术就是一种典型空间换时间的策略，我们使用的数据库连接池、线程池等都是池化技术的应用，Python标准库currrent.futures模块的ThreadPoolExecutor就是线程池的实现，如果要弄清楚它的工作原理，可以参考下面的内容。\n 线程池是一种用于减少线程本身创建和销毁造成的开销的技术，属于典型的空间换时间操作。如果应用程序需要频繁的将任务派发到线程中执行，线程池就是必选项，因为创建和释放线程涉及到大量的系统底层操作，开销较大，如果能够在应用程序工作期间，将创建和释放线程的操作变成预创建和借还操作，将大大减少底层开销。线程池在应用程序启动后，立即创建一定数量的线程，放入空闲队列中。这些线程最开始都处于阻塞状态，不会消耗CPU资源，但会占用少量的内存空间。当任务到来后，从队列中取出一个空闲线程，把任务派发到这个线程中运行，并将该线程标记为已占用。当线程池中所有的线程都被占用后，可以选择自动创建一定数量的新线程，用于处理更多的任务，也可以选择让任务排队等待直到有空闲的线程可用。在任务执行完毕后，线程并不退出结束，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程长时间处于闲置状态时，线程池可以自动销毁一部分线程，回收系统资源。基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小。\n一般线程池都必须具备下面几个组成部分：\n 线程池管理器：用于创建并管理线程池。 工作线程和线程队列：线程池中实际执行的线程以及保存这些线程的容器。 任务接口：将线程执行的任务抽象出来，形成任务接口，确保线程池与具体的任务无关。 任务队列：线程池中保存等待被执行的任务的容器。  题目38：举例说明什么情况下会出现KeyError、TypeError、ValueError。 举一个简单的例子，变量a是一个字典，执行int(a['x'])这个操作就有可能引发上述三种类型的异常。如果字典中没有键x，会引发KeyError；如果键x对应的值不是str、float、int、bool以及bytes-like类型，在调用int函数构造int类型的对象时，会引发TypeError；如果a[x]是一个字符串或者字节串，而对应的内容又无法处理成int时，将引发ValueError。\n题目39：说出下面代码的运行结果。 1 2 3 4 5 6 7 8 9 10  def extend_list(val, items=[]): items.append(val) return items list1 = extend_list(10) list2 = extend_list(123, []) list3 = extend_list(\u0026#39;a\u0026#39;) print(list1) print(list2) print(list3)    点评：Python函数在定义的时候，默认参数items的值就被计算出来了，即[]。因为默认参数items引用了对象[]，每次调用该函数，如果对items引用的列表进行了操作，下次调用时，默认参数还是引用之前的那个列表而不是重新赋值为[]，所以列表中会有之前添加的元素。如果通过传参的方式为items重新赋值，那么items将引用到新的列表对象，而不再引用默认的那个列表对象。这个题在面试中经常被问到，通常不建议使用容器类型的默认参数，像PyLint这样的代码检查工具也会对这种代码提出质疑和警告。\n [10, 'a'] [123] [10, 'a'] 题目40：如何读取大文件，例如内存只有4G，如何读取一个大小为8G的文件？ 很显然4G内存要一次性的加载大小为8G的文件是不现实的，遇到这种情况必须要考虑多次读取和分批次处理。在Python中读取文件可以先通过open函数获取文件对象，在读取文件时，可以通过read方法的size参数指定读取的大小，也可以通过seek方法的offset参数指定读取的位置，这样就可以控制单次读取数据的字节数和总字节数。除此之外，可以使用内置函数iter将文件对象处理成迭代器对象，每次只读取少量的数据进行处理，代码大致写法如下所示。\n1 2 3  with open(\u0026#39;...\u0026#39;, \u0026#39;rb\u0026#39;) as file: for data in iter(lambda: file.read(2097152), b\u0026#39;\u0026#39;): pass   在Linux系统上，可以通过split命令将大文件切割为小片，然后通过读取切割后的小文件对数据进行处理。例如下面的命令将名为filename的大文件切割为大小为512M的多个文件。\n1  split -b 512m filename   如果愿意， 也可以将名为filename的文件切割为10个文件，命令如下所示。\n1  split -n 10 filename    扩展：外部排序跟上述的情况非常类似，由于处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。“排序-归并算法”就是一种常用的外部排序策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件，然后在归并阶段将这些临时文件组合为一个大的有序文件，这个大的有序文件就是排序的结果。\n 题目41：说一下你对Python中模块和包的理解。 每个Python文件就是一个模块，而保存这些文件的文件夹就是一个包，但是这个作为Python包的文件夹必须要有一个名为__init__.py的文件，否则无法导入这个包。通常一个文件夹下还可以有子文件夹，这也就意味着一个包下还可以有子包，子包中的__init__.py并不是必须的。模块和包解决了Python中命名冲突的问题，不同的包下可以有同名的模块，不同的模块下可以有同名的变量、函数或类。在Python中可以使用import或from ... import ...来导入包和模块，在导入的时候还可以使用as关键字对包、模块、类、函数、变量等进行别名，从而彻底解决编程中尤其是多人协作团队开发时的命名冲突问题。\n题目42：说一下你知道的Python编码规范。  点评：企业的Python编码规范基本上是参照PEP-8或谷歌开源项目风格指南来制定的，后者还提到了可以使用Lint工具来检查代码的规范程度，面试的时候遇到这类问题，可以先说下这两个参照标准，然后挑重点说一下Python编码的注意事项。\n   空格的使用\n 使用空格来表示缩进而不要用制表符（Tab）。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。    标识符命名\n 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。    表达式和语句\n 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如：if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。    题目43：运行下面的代码是否会报错，如果报错请说明哪里有什么样的错，如果不报错请说出代码的执行结果。 1 2 3 4 5 6 7 8 9 10 11 12  class A: def __init__(self, value): self.__value = value @property def value(self): return self.__value obj = A(1) obj.__value = 2 print(obj.value) print(obj.__value)    点评：这道题有两个考察点，一个考察点是对_和__开头的对象属性访问权限以及@property装饰器的了解，另外一个考察的点是对动态语言的理解，不需要过多的解释。\n 1 2  扩展：如果不希望代码运行时动态的给对象添加新属性，可以在定义类时使用__slots__魔法。例如，我们可以在上面的A中添加一行__slots__ = ('__value', )，再次运行上面的代码，将会在原来的第10行处产生AttributeError错误。\n 题目44：对下面给出的字典按值从大到小对键进行排序。 1 2 3 4 5 6 7 8 9  prices = { \u0026#39;AAPL\u0026#39;: 191.88, \u0026#39;GOOG\u0026#39;: 1186.96, \u0026#39;IBM\u0026#39;: 149.24, \u0026#39;ORCL\u0026#39;: 48.44, \u0026#39;ACN\u0026#39;: 166.89, \u0026#39;FB\u0026#39;: 208.09, \u0026#39;SYMC\u0026#39;: 21.29 }    点评：sorted函数的高阶用法在面试的时候经常出现，key参数可以传入一个函数名或一个Lambda函数，该函数的返回值代表了在排序时比较元素的依据。\n 1  sorted(prices, key=lambda x: prices[x], reverse=True)   题目45：说一下namedtuple的用法和作用。  点评：Python标准库的collections模块提供了很多有用的数据结构，这些内容并不是每个开发者都清楚，就比如题目问到的namedtuple，在我参加过的面试中，90%的面试者都不能准确的说出它的作用和应用场景。此外，deque也是一个非常有用但又经常被忽视的类，还有Counter、OrderedDict 、defaultdict 、UserDict等类，大家清楚它们的用法吗？\n 在使用面向对象编程语言的时候，定义类是最常见的一件事情，有的时候，我们会用到只有属性没有方法的类，这种类的对象通常只用于组织数据，并不能接收消息，所以我们把这种类称为数据类或者退化的类，就像C语言中的结构体那样。我们并不建议使用这种退化的类，在Python中可以用namedtuple（命名元组）来替代这种类。\n1 2 3 4 5 6 7  from collections import namedtuple Card = namedtuple(\u0026#39;Card\u0026#39;, (\u0026#39;suite\u0026#39;, \u0026#39;face\u0026#39;)) card1 = Card(\u0026#39;红桃\u0026#39;, 13) card2 = Card(\u0026#39;草花\u0026#39;, 5) print(f\u0026#39;{card1.suite}{card1.face}\u0026#39;) print(f\u0026#39;{card2.suite}{card2.face}\u0026#39;)   命名元组与普通元组一样是不可变容器，一旦将数据存储在namedtuple的顶层属性中，数据就不能再修改了，也就意味着对象上的所有属性都遵循“一次写入，多次读取”的原则。和普通元组不同的是，命名元组中的数据有访问名称，可以通过名称而不是索引来获取保存的数据，不仅在操作上更加简单，代码的可读性也会更好。\n命名元组的本质就是一个类，所以它还可以作为父类创建子类。除此之外，命名元组内置了一系列的方法，例如，可以通过_asdict方法将命名元组处理成字典，也可以通过_replace方法创建命名元组对象的浅拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12  class MyCard(Card): def show(self): faces = [\u0026#39;\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;K\u0026#39;] return f\u0026#39;{self.suite}{faces[self.face]}\u0026#39; print(Card) # \u0026lt;class \u0026#39;__main__.Card\u0026#39;\u0026gt; card3 = MyCard(\u0026#39;方块\u0026#39;, 12) print(card3.show()) # 方块Q print(dict(card1._asdict())) # {\u0026#39;suite\u0026#39;: \u0026#39;红桃\u0026#39;, \u0026#39;face\u0026#39;: 13} print(card2._replace(suite=\u0026#39;方块\u0026#39;)) # Card(suite=\u0026#39;方块\u0026#39;, face=5)   总而言之，命名元组能更好的组织数据结构，让代码更加清晰和可读，在很多场景下是元组、字典和数据类的替代品。在需要创建占用空间更少的不可变类时，命名元组就是很好的选择。\n题目46：按照题目要求写出对应的函数。  要求：写一个函数，传入一个有若干个整数的列表，该列表中某个元素出现的次数超过了50%，返回这个元素。\n 1 2 3 4 5 6 7 8 9 10 11 12  def more_than_half(items): temp, times = None, 0 for item in items: if times == 0: temp = item times += 1 else: if item == temp: times += 1 else: times -= 1 return temp    点评：LeetCode上的题目，在Python面试中出现过，利用元素出现次数超过了50%这一特征，出现和temp相同的元素就将计数值加1，出现和temp不同的元素就将计数值减1。如果计数值为0，说明之前出现的元素已经对最终的结果没有影响，用temp记下当前元素并将计数值置为1。最终，出现次数超过了50%的这个元素一定会被赋值给变量temp。\n 题目47：按照题目要求写出对应的函数。  要求：写一个函数，传入的参数是一个列表（列表中的元素可能也是一个列表），返回该列表最大的嵌套深度。例如：列表[1, 2, 3]的嵌套深度为1，列表[[1], [2, [3]]]的嵌套深度为3。\n 1 2 3 4 5 6 7  def list_depth(items): if isinstance(items, list): max_depth = 1 for item in items: max_depth = max(list_depth(item) + 1, max_depth) return max_depth return 0    点评：看到题目应该能够比较自然的想到使用递归的方式检查列表中的每个元素。\n 题目48：按照题目要求写出对应的装饰器。  要求：有一个通过网络获取数据的函数（可能会因为网络原因出现异常），写一个装饰器让这个函数在出现指定异常时可以重试指定的次数，并在每次重试之前随机延迟一段时间，最长延迟时间可以通过参数进行控制。\n 方法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from functools import wraps from random import random from time import sleep def retry(*, retry_times=3, max_wait_secs=5, errors=(Exception, )): def decorate(func): @wraps(func) def wrapper(*args, **kwargs): for _ in range(retry_times): try: return func(*args, **kwargs) except errors: sleep(random() * max_wait_secs) return None return wrapper return decorate   方法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from functools import wraps from random import random from time import sleep class Retry(object): def __init__(self, *, retry_times=3, max_wait_secs=5, errors=(Exception, )): self.retry_times = retry_times self.max_wait_secs = max_wait_secs self.errors = errors def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): for _ in range(self.retry_times): try: return func(*args, **kwargs) except self.errors: sleep(random() * self.max_wait_secs) return None return wrapper    点评：我们不止一次强调过，装饰器几乎是Python面试必问内容，这个题目比之前的题目稍微复杂一些，它需要的是一个参数化的装饰器。\n 题目49：写一个函数实现字符串反转，尽可能写出你知道的所有方法。  点评：烂大街的题目，基本上算是送人头的题目。\n 方法一：反向切片\n1 2  def reverse_string(content): return content[::-1]   方法二：反转拼接\n1 2  def reverse_string(content): return \u0026#39;\u0026#39;.join(reversed(content))   方法三：递归调用\n1 2 3 4  def reverse_string(content): if len(content) \u0026lt;= 1: return content return reverse_string(content[1:]) + content[0]   方法四：双端队列\n1 2 3 4 5 6  from collections import deque def reverse_string(content): q = deque() q.extendleft(content) return \u0026#39;\u0026#39;.join(q)   方法五：反向组装\n1 2 3 4 5 6 7  from io import StringIO def reverse_string(content): buffer = StringIO() for i in range(len(content) - 1, -1, -1): buffer.write(content[i]) return buffer.getvalue()   方法六：反转拼接\n1 2  def reverse_string(content): return \u0026#39;\u0026#39;.join([content[i] for i in range(len(content) - 1, -1, -1)])   方法七：半截交换\n1 2 3 4 5  def reverse_string(content): length, content= len(content), list(content) for i in range(length // 2): content[i], content[length - 1 - i] = content[length - 1 - i], content[i] return \u0026#39;\u0026#39;.join(content)   方法八：对位交换\n1 2 3 4 5  def reverse_string(content): length, content= len(content), list(content) for i, j in zip(range(length // 2), range(length - 1, length // 2 - 1, -1)): content[i], content[j] = content[j], content[i] return \u0026#39;\u0026#39;.join(content)    扩展：这些方法其实都是大同小异的，面试的时候能够给出几种有代表性的就足够了。给大家留一个思考题，上面这些方法，哪些做法的性能较好呢？我们之前提到过剖析代码性能的方法，大家可以用这些方法来检验下你给出的答案是否正确。\n 题目50：按照题目要求写出对应的函数。  要求：列表中有1000000个元素，取值范围是[1000, 10000)，设计一个函数找出列表中的重复元素。\n 1 2 3 4 5 6 7  def find_dup(items: list): dups = [0] * 9000 for item in items: dups[item - 1000] += 1 for idx, val in enumerate(dups): if val \u0026gt; 1: yield idx + 1000    点评：这道题的解法和计数排序的原理一致，虽然元素的数量非常多，但是取值范围[1000, 10000)并不是很大，只有9000个可能的取值，所以可以用一个能够保存9000个元素的dups列表来记录每个元素出现的次数，dups列表所有元素的初始值都是0，通过对items列表中元素的遍历，当出现某个元素时，将dups列表对应位置的值加1，最后dups列表中值大于1的元素对应的就是items列表中重复出现过的元素。\n 摘自《Python面试宝典》。\n","date":"2023-03-27T00:00:00Z","permalink":"https://frank2016ma.github.io/seattle/posts/python-meeting/","title":"Python Meeting"}]