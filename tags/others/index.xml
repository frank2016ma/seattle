<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>others on Frank in seattle</title>
        <link>https://frank2016ma.github.io/seattle/tags/others/</link>
        <description>Recent content in others on Frank in seattle</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 26 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://frank2016ma.github.io/seattle/tags/others/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>一些 Linux 命令</title>
        <link>https://frank2016ma.github.io/seattle/drafts/linux-tools/</link>
        <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/drafts/linux-tools/</guid>
        <description>Linux命令 scp scp 命令 - SSH 教程 - 网道
1 2 3 4 5 6 7 8  # 复制本地文件到远程机器 scp local_file remote_username@remote_ip:remote_folder # 复制远程文件到本地 scp remote_username@remote_ip:remote_file local_folder # (递归)复制目录 scp -r local_folder remote_username@remote_ip:remote_folder   which which指令会在环境变量$PATH设置的目录里查找符合条件的文件
1 2  which bash # /usr/bin/bash   1 2  docker exec -it qinglong2 /usr/bin/fish OCI runtime exec failed: exec failed: unable to start container process: exec: &amp;#34;/usr/bin/fish&amp;#34;: stat /usr/bin/fish: no such file or directory: unknown   上面这段命令中, /usr/bin/fish 的路径是指 qinglong2 中的路径, docker镜像中没有安装 fish, 所以报错找不到文件或者路径, 通常大部分镜像只能使用bash, 有部分镜像使用bash也会出现如上报错, 需要使用 sh</description>
        </item>
        <item>
        <title>Win11 Brightness</title>
        <link>https://frank2016ma.github.io/seattle/posts/win11-brightness/</link>
        <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/win11-brightness/</guid>
        <description>Windows11 系统的笔记本电脑在使用电源时, 会出现偶尔屏幕变暗又恢复的情况
解决方法:
打开 设置 &amp;gt; 系统 &amp;gt; 屏幕, 点击亮度调节 右侧下拉选项, 取消勾选 通过优化显示的内容和亮度降低电池能耗</description>
        </item>
        <item>
        <title>Python Meeting</title>
        <link>https://frank2016ma.github.io/seattle/posts/python-meeting/</link>
        <pubDate>Mon, 27 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python-meeting/</guid>
        <description>题目001: 在Python中如何实现单例模式。  点评：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对Python语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。
 方法一：使用装饰器实现单例模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from functools import wraps def singleton(cls): &amp;#34;&amp;#34;&amp;#34;单例类装饰器&amp;#34;&amp;#34;&amp;#34; instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President: pass    扩展：装饰器是Python中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的wrapper函数）通常都会用functools模块中的wraps再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个__wrapped__属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用President = President.__wrapped__来取消对President类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在Python中可以使用threading模块的RLock对象来提供锁，可以使用锁对象的acquire和release方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的with上下文语法来进行隐式的加锁和解锁操作。
 方法二：使用元类实现单例模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class SingletonMeta(type): &amp;#34;&amp;#34;&amp;#34;自定义单例元类&amp;#34;&amp;#34;&amp;#34; def __init__(cls, *args, **kwargs): cls.</description>
        </item>
        
    </channel>
</rss>
