<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>others on Frank in seattle</title>
        <link>https://frank2016ma.github.io/seattle/tags/others/</link>
        <description>Recent content in others on Frank in seattle</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 26 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://frank2016ma.github.io/seattle/tags/others/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>一些 Linux 命令</title>
        <link>https://frank2016ma.github.io/seattle/drafts/linux-tools/</link>
        <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/drafts/linux-tools/</guid>
        <description>Linux命令 scp scp 命令 - SSH 教程 - 网道
# 复制本地文件到远程机器 scp local_file remote_username@remote_ip:remote_folder # 复制远程文件到本地 scp remote_username@remote_ip:remote_file local_folder # (递归)复制目录 scp -r local_folder remote_username@remote_ip:remote_folder which which指令会在环境变量$PATH设置的目录里查找符合条件的文件
which bash # /usr/bin/bash docker exec -it qinglong2 /usr/bin/fish OCI runtime exec failed: exec failed: unable to start container process: exec: &amp;#34;/usr/bin/fish&amp;#34;: stat /usr/bin/fish: no such file or directory: unknown 上面这段命令中, /usr/bin/fish 的路径是指 qinglong2 中的路径, docker镜像中没有安装 fish, 所以报错找不到文件或者路径, 通常大部分镜像只能使用bash, 有部分镜像使用bash也会出现如上报错, 需要使用 sh
examples 将 log 文件夹的所有.</description>
        </item>
        <item>
        <title>TOML</title>
        <link>https://frank2016ma.github.io/seattle/posts/toml/</link>
        <pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/toml/</guid>
        <description>规格  TOML 是大小写敏感的 TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档 空白是指制表符(0x09)或空格(0x20) 换行是指 LF(0x0A)或 CRLF(0x0D 0x0A) 使用 # 符号作为注释  键值对 TOML 文档最基本的构成区块是键值对, 键名和键值周围的空白会被忽略
多次定义同一个key是非法的
key = &amp;#34;value&amp;#34; 点分隔符 name = &amp;#34;Orange&amp;#34; physical.color = &amp;#34;orange&amp;#34; physical.shape = &amp;#34;round&amp;#34; site.&amp;#34;google.com&amp;#34; = true # 引号内的点不会作为分隔符 等价于
{ &amp;#34;name&amp;#34;: &amp;#34;Orange&amp;#34;, &amp;#34;physical&amp;#34;: { &amp;#34;color&amp;#34;: &amp;#34;orange&amp;#34;, &amp;#34;shape&amp;#34;: &amp;#34;round&amp;#34; }, &amp;#34;site&amp;#34;: { &amp;#34;google.com&amp;#34;: true } } 表 表（也被称为哈希表或字典）是键值对的集合 它们由表头定义，连同方括号作为单独的行出现 表头不同于数组，因为数组只有值 缩进会被忽略
从表头下方, 直至下一个表头或者文件结束, 都是这个表的键值对
[table-1] key1 = &amp;#34;some string&amp;#34; key2 = 123 [table-2] key1 = &amp;#34;another string&amp;#34; key2 = 456 等价于</description>
        </item>
        <item>
        <title>Win11 Brightness</title>
        <link>https://frank2016ma.github.io/seattle/posts/win11-brightness/</link>
        <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/win11-brightness/</guid>
        <description>Windows11 系统的笔记本电脑在使用电源时, 会出现偶尔屏幕变暗又恢复的情况
解决方法:
打开 设置 &amp;gt; 系统 &amp;gt; 屏幕, 点击亮度调节 右侧下拉选项, 取消勾选 通过优化显示的内容和亮度降低电池能耗
 </description>
        </item>
        <item>
        <title>Python Meeting</title>
        <link>https://frank2016ma.github.io/seattle/posts/python-meeting/</link>
        <pubDate>Mon, 27 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python-meeting/</guid>
        <description>题目001: 在Python中如何实现单例模式。  点评：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对Python语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。
 方法一：使用装饰器实现单例模式。
from functools import wraps def singleton(cls): &amp;#34;&amp;#34;&amp;#34;单例类装饰器&amp;#34;&amp;#34;&amp;#34; instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President: pass  扩展：装饰器是Python中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的wrapper函数）通常都会用functools模块中的wraps再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个__wrapped__属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用President = President.__wrapped__来取消对President类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在Python中可以使用threading模块的RLock对象来提供锁，可以使用锁对象的acquire和release方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的with上下文语法来进行隐式的加锁和解锁操作。
 方法二：使用元类实现单例模式。
class SingletonMeta(type): &amp;#34;&amp;#34;&amp;#34;自定义单例元类&amp;#34;&amp;#34;&amp;#34; def __init__(cls, *args, **kwargs): cls.__instance = None super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): pass  扩展：Python是面向对象的编程语言，在面向对象的世界中，一切皆为对象。对象是通过类来创建的，而类本身也是对象，类这样的对象是通过元类来创建的。我们在定义类时，如果没有给一个类指定父类，那么默认的父类是object，如果没有给一个类指定元类，那么默认的元类是type。通过自定义的元类，我们可以改变一个类默认的行为，就如同上面的代码中，我们通过元类的__call__魔术方法，改变了President类的构造器那样。</description>
        </item>
        
    </channel>
</rss>
