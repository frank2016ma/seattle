<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Frank in seattle</title>
        <link>https://frank2016ma.github.io/seattle/</link>
        <description>Recent content on Frank in seattle</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 25 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://frank2016ma.github.io/seattle/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>关于 Excel 单元格数字格式、真实值和显示值</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/excel/excel-realvalue-displayvalue/</link>
        <pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/excel/excel-realvalue-displayvalue/</guid>
        <description>在使用脚本语言对Excel文件进行操作时, 有时会发现, 脚本读取出的值和实际在Excel单元格中显示的值不一致的情况 搜索资料后整理出如下笔记
Number Format(数字格式) Excel 已经有许多内置的数字格式, 如 货币, 百分比等, 你还可以根据自己的需求设置自定义的数字格式
 Applying a number format only changes how the number is displayed and doesn’t affect cell values that’s used to perform calculations. You can see the actual value in the formula bar.
应用数字格式只会改变数字的显示方式, 并不会影响用于计算的单元格值. 在公式栏(编辑栏)中可以看到实际的值
  注意: 公式栏中显示的也不一定是单元格内容的真实值, 有些数字格式, 本身是一种复杂的数据类型, 比如日期, 公式栏中显示的值, 类似编程语言中默认的 toString() 方法的结果, 而对单元格设置数字格式后的显示值, 类似 format() 方法的结果
 单元格的数字精度问题 当数字的长度达到12位及以上, 会自动以科学计数法显示该数字(仅限Microsoft Excel)
经实测在WPS表格中, 数字达到12位及以上, 会以文本格式显示该内容(默认靠左对齐, 完整显示内容), 而非科学计数法</description>
        </item>
        <item>
        <title>Pandas 追加写入 Excel 表格</title>
        <link>https://frank2016ma.github.io/seattle/posts/python/pandas-append-range-to-sheet/</link>
        <pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python/pandas-append-range-to-sheet/</guid>
        <description>DataFrame 写入 Excel 文件 下面两段代码用于直接生成 Excel 文件, 如果文件已经存在, 会被覆盖
1 2 3 4 5 6 7 8 9 10 11  # sht2, sht3 两张表都会被写入 with pd.ExcelWriter(path=r&amp;#39;path_to_file.xlsx&amp;#39;) as writer: df.to_excel(ew, sheet_name=&amp;#39;sht2&amp;#39;, index=False) df.to_excel(ew, sheet_name=&amp;#39;sht3&amp;#39;, index=False) # 第二次会覆盖掉第一次的 # 只剩下 sht3 with pd.ExcelWriter(path=r&amp;#39;path_to_file.xlsx&amp;#39;) as writer: df.to_excel(ew, sheet_name=&amp;#39;sht2&amp;#39;, index=False) with pd.ExcelWriter(path=r&amp;#39;path_to_file.xlsx&amp;#39;) as writer: df.to_excel(ew, sheet_name=&amp;#39;sht3&amp;#39;, index=False)    DataFrame 追加写入 Excel 文件 如果要往一份已经存在的Excel文件中追加内容, 如往含有标题的模板中填写数据或者在已有数据末尾追加数据
pandas 1.4.0之前的版本 在 pandas 1.4.0 之前, 可以使用如下方法将 DataFrame 追加写入 Excel 文件</description>
        </item>
        <item>
        <title>WebSocket</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/websocket/</link>
        <pubDate>Mon, 26 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/websocket/</guid>
        <description>Introducing websocket 的最大特点就是, 服务器可以主动向客户端推送消息, 客户端也可以主动向服务器发送消息
 While a WebSocket connection is functionally somewhat similar to standard Unix-style sockets, they are not related.
 尽管 WebSocket 连接 在功能上和 标准的 Unix 风格的socket 类似, 但是这两者之间并没有关联
为什么需要websocket HTTP 协议有一个缺陷, 通信只能有客户端发起
js客户端websocket 构造函数创建websocket实例 1  const exampleSocket = new WebSocket(&amp;#34;wss://www.example.com/socketserver&amp;#34;);   websocket.readyState  0: CONNECTING 1: OPEN 2: CLOSING 3: CLOSED  指定回调函数 oncode, onmessage, readState 等是 属性()
send(), close() 是方法
onopen 1 2 3  ws.</description>
        </item>
        <item>
        <title>Mixin</title>
        <link>https://frank2016ma.github.io/seattle/posts/python/docs/mixin/</link>
        <pubDate>Sun, 25 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python/docs/mixin/</guid>
        <description>Mixin (mix-in), 是一种编程模式, 和多重继承类似
首先，需要注意的是混合（Mixin）仅存在于支持多重继承的编程语言中。在Java或C#等不支持多重继承的语言中，无法直接使用混合。
在不支持混合的语言中，可以使用其他替代方法来达到类似的效果。 例如，在Java中，可以通过接口（Interface）和委托（Delegation）等技术来实现一些混合的特性。接口允许类实现多个接口以获取不同的功能，而委托则允许类将某些功能委托给其他对象来实现。
然而，在真正的混合模式中，通过多重继承可以直接将多个类的功能组合到一个类中，而不需要接口或委托的复杂处理。 因此，在只支持单一继承的语言中，实现类似混合的功能可能会更加繁琐和复杂。
在 Python 等面向对象语言中，通常它是实现了某种功能单元的类，用于被其他子类继承，将功能组合到子类中
当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 Mixin 类
在面向对象编程语言中，混合（Mixin）是一个包含方法的类，其他类可以使用这些方法，而无需将其作为父类。 其他类如何访问混合类的方法取决于所使用的编程语言。有时，混合类被描述为&amp;quot;被包含&amp;quot;而不是&amp;quot;被继承&amp;quot;。 混合类的主要目的是通过提供可重用的功能和行为来增强其他类，而无需创建复杂的继承关系。通过混合，类可以在不增加继承层次结构的同时获得新的方法和特性，提供了更大的灵活性和可复用性。混合是一种常见的编程技术，被广泛应用于许多面向对象编程语言中。
Mixin 是一种特殊的多重继承方式。混合通常用于以下两种主要情况：
当您希望为一个类提供许多可选功能时，可以使用 Mixin。 当您希望在许多不同的类中使用某个特定功能时，可以使用 Mixin。
 Python mixin
python - What is a mixin and why is it useful? - Stack Overflow
Mixin - Wikipedia</description>
        </item>
        <item>
        <title>Image2ASCII</title>
        <link>https://frank2016ma.github.io/seattle/posts/python/image2ascii/</link>
        <pubDate>Fri, 23 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python/image2ascii/</guid>
        <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  import tkinter as tk from tkinter import messagebox from PIL import ImageTk, Image import os # 定义字符映射表 # 不懂区间的灰度值对应不同的字符 CHARS = &amp;#39;@%#*+=-:.</description>
        </item>
        <item>
        <title>python 实现简易多人聊天室</title>
        <link>https://frank2016ma.github.io/seattle/posts/python/chat-room/</link>
        <pubDate>Fri, 23 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python/chat-room/</guid>
        <description>原理 实现一个多人聊天室需要两个部分, client 端 和server 端
client 端只和server端进行通信, 不同的client之间是不会直接通信的
实现需要两个核心的库, socket 和 threading
socket 用来实现网络中的多个节点并进行通信
threading 模块用于支持多线程(python有全局解释锁, 所以是伪多线程)
Server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  class ChatServer: def __init__(self, host, port) -&amp;gt; None: self.</description>
        </item>
        <item>
        <title>Archives</title>
        <link>https://frank2016ma.github.io/seattle/archives/</link>
        <pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/archives/</guid>
        <description></description>
        </item>
        <item>
        <title>Quick Start</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/react/quick-start/</link>
        <pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/react/quick-start/</guid>
        <description>React apps are made out of components A component is a piece of the UI(user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page
 React component names must always start with a capital letter, while HTML tags must be lowercase.
 writing markup with JSX 1 2 3 4 5  export default function MyApp(){ return ( &amp;lt;div&amp;gt;MyApp&amp;lt;/div&amp;gt; ) }   The export default keywords specify the main component in the file.</description>
        </item>
        <item>
        <title>Sed 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/sed-cheat-sheet/</link>
        <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/sed-cheat-sheet/</guid>
        <description>sed 语法 sed [options]... [script] [input-file]
sed 默认输入输出为 stdin, stdout
 sed treats multiple input files as one long stream. The following example prints the first line of the first file (one.txt) and the last line of the last file (three.txt). Use -s to reverse this behavior. 下面的命令中, sed 将 one two three 三个文件当作一个输入, 所以只会输出 one文件的第一行和 three 文件的最后一行
 sed -n &#39;1p ; $p&#39; one.txt two.txt three.txt
options -n --quiet</description>
        </item>
        <item>
        <title>Spread Syntax</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/spread-syntax/</link>
        <pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/spread-syntax/</guid>
        <description>展开语法(Spread syntax) 在函数调用/数组构造时, 将数组表达式或者string在语法层面展开; 还可以在构造字面量时, 将对象按照 key-value 的方式展开
语法 myFunction(&amp;hellip;iterableObj);
实例 在函数调用时使用展开语法 等价于apply 1 2 3 4 5 6  function myFunction(x, y, z) {}; var args = [0, 1, 2] myfunction.apply(null, args); // 使用展开语法 myfunction(...args)   构造字面量数组 1 2 3 4 5 6 7 8  var parts = [&amp;#39;apple&amp;#39;, &amp;#39;banana&amp;#39;] var fruits = [&amp;#39;pear&amp;#39;, ...parts, &amp;#39;watermelon&amp;#39;] var arr = [1, 2, 3] var arr2 = [...arr] // like arr.</description>
        </item>
        <item>
        <title>Xargs 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/xargs-cheatsheet/</link>
        <pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/xargs-cheatsheet/</guid>
        <description>xargs命令的作用，是将标准输入转为命令行参数(使用xargs的原因是, 很多命令不支持标准输入传递参数, 如echo, ls)
默认情况下, xargs将换行符和空格作为分隔符, 把标准输入分解成一个个命令行参数
-d 参数可以更改分隔符 input file names are terminated by the specified character delim instead of by whitespace
-L max-lines Use at most max-lines non-blank input lines per command line. for -L the argument is mandatory. Trailing blanks cause an input line to be logically continued on the next input line The -l form of this option is deprecated in favour of the POSIX-compliant -L option.</description>
        </item>
        <item>
        <title>Promise</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/promise/</link>
        <pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/promise/</guid>
        <description>回调函数是异步操作最基本的方法
1 2 3 4 5 6 7 8 9 10 11  function f1(callback) { // ...  callback(); } function f2() { // ... } f1(f2); // 把 f2 写成 f1 的回调函数   sedTimeout(func|code, delay) 一段时间之后执行某个函数或某段代码
setInterval(func|code, delay) 每隔一段时间就执行一次
Promise含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise对象有以下两个特点。
（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
语法 1 2 3 4 5 6 7 8 9  const promise = new Promise(function(resolve, reject) { // .</description>
        </item>
        <item>
        <title>Axios 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/axios-cheat-sheet/</link>
        <pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/axios-cheat-sheet/</guid>
        <description>axios install  npm install axios &amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://unpkg.com/axios/dist/axios.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  example 1 2 3 4 5 6 7 8 9 10 11 12  axios.get(&amp;#39;/user?ID=12345&amp;#39;) .then(function (response) { // handle success  console.log(response); }) .catch(function (error) { // handle error  console.log(error); }) .finally(function () { // always executed  });   </description>
        </item>
        <item>
        <title>Tic Tac Toe</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/react/tic-tac-toe/</link>
        <pubDate>Mon, 05 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/react/tic-tac-toe/</guid>
        <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  import { useState } from &amp;#39;react&amp;#39;; /* React provides a special function called useState that you can call from your component to let it “remember” things.</description>
        </item>
        <item>
        <title>Hugo Copy Code</title>
        <link>https://frank2016ma.github.io/seattle/posts/hugo/hugo-copy-code/</link>
        <pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/hugo/hugo-copy-code/</guid>
        <description>使用hugo建站, 点击代码块中右上角的 Copy按钮时, 发现没有生效
仔细对比了一下stack主题的config文件以及content文件夹下的markdown源码, 复制代码并不需要额外特殊设置, 于是打开控制台, 发现确实有代码报错, 报错信息如下
Uncaught TypeError: Cannot read properties of undefined (reading &#39;writeText&#39;) at HTMLButtonElement.&amp;lt;anonymous&amp;gt; (main.js:4:429) (匿名) @ main.js:4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let r = document.querySelectorAll(&amp;#34;.article-content div.highlight&amp;#34;) , i = &amp;#34;Copy&amp;#34; , n = &amp;#34;Copied!&amp;#34;; r.forEach(o=&amp;gt;{ let s = document.createElement(&amp;#34;button&amp;#34;); s.innerHTML = i, s.</description>
        </item>
        <item>
        <title>Hugo Shortcodes</title>
        <link>https://frank2016ma.github.io/seattle/posts/hugo/hugo-shortcodes/</link>
        <pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/hugo/hugo-shortcodes/</guid>
        <description>Built-in Shortcodes figure Shortcodes - figure | Hugo
highlight 用于展示代码片段, 通常情况下 展示代码使用 markdown 语法即可, 是否显示行号, 代码起始行号等可以在配置文件中设置
 渲染结果如下:
42{{ range .Pages }} 43 &amp;lt;h2&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .LinkTitle }}&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt; 44{{ end }} ref &amp;amp; relref 渲染如下:
hugo-image
第三方 Shortcodes stack quote 1     效果如下: </description>
        </item>
        <item>
        <title>apt 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/apt-cheat-sheet/</link>
        <pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/apt-cheat-sheet/</guid>
        <description>apt(Advanced Package Tool) apt 是 Debian 系的Linux发行版默认的软件包管理器, 本文暂不讨论apt 和 apt-get 的关系与区别
apt命令必须以具有sudo权限的用户运行, 以下示例省略前面的sudo
search apt search package_name
show apt show package_name 显示有关给定软件包的信息，包括其依赖项、安装、下载大小、软件包可用的来源、软件包内容的描述等
install apt install package1 package2 安装软件包, 多个软件包名使用空格分隔
update &amp;amp; upgrade apt update 从APT存储库中获取最新索引数据
apt upgrade 将已安装的软件包升级到最新版本
apt upgrade package_name 升级单个软件包
list apt list --installed 列出已安装的软件包
apt list --upgradeable 获取可升级软件包的列表
remove &amp;amp; purge remove 和 purge 的区别: remove 保留软件包的配置文件, 而 purge 会卸载软件包并删除配置文件
PS: 当我们安装了一个软件包, 发现某些设置和默认的设置不一致时, 需要注意是不是之前安装过这个软件, 然后使用remove删除, 重新安装之后使用了之前的配置文件导致的
apt remove package_name</description>
        </item>
        <item>
        <title>Python 魔法变量</title>
        <link>https://frank2016ma.github.io/seattle/posts/python/python-kwargs/</link>
        <pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python/python-kwargs/</guid>
        <description>1 2 3 4  dt = {&amp;#39;sep&amp;#39;: &amp;#39; # &amp;#39;, &amp;#39;end&amp;#39;: &amp;#39;\n\n&amp;#39;} print(&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;, **dt) # 等价于 print(&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;, sep=&amp;#39; # &amp;#39;, end=&amp;#39;\n\n&amp;#39;)   </description>
        </item>
        <item>
        <title>编程文档中的 Foo Bar</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/foo-bar/</link>
        <pubDate>Wed, 31 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/foo-bar/</guid>
        <description>许多软件文档中, 代码示例的部分, 经常会使用 &amp;lsquo;foobar&amp;rsquo;或者 &amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo; 作为变量, 这两个单词具体是什么意思有点困惑, 词典给出的中文翻译都联系不上
tl;dr:
结合国情来理解, foo 和 bar 就是课文中的小明和小红, 罗翔刑法案例中的张三, 张宇高数课, 等价无穷小公式中的狗
以下是维基百科给出的详细解释:
Foobar - Wikipedia
 在编程中, 还有许多类似的约定俗成的占位符
比如 python 中的 单下划线_, 表示某个临时的无关紧要的变量
xargs命令参数中的 -I {}
find命令 -exec 参数后 的 {}</description>
        </item>
        <item>
        <title>golang 日期格式化</title>
        <link>https://frank2016ma.github.io/seattle/posts/golang/go-time-format-2006-01-02/</link>
        <pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/golang/go-time-format-2006-01-02/</guid>
        <description>大部分编程语言中, 格式化日期的方式都是使用 YYYMMddHHMMSS 类似的字符串, 又或者是 %Y%m 之类的字符串
而 golang 比较奇特, 日期格式化是使用一个具体的日期常量 2006-01-02 15:04:05 的不同表示方法来设置格式
 这个日期可以记为 1 月 2 日, 下午 3 点 4 分 5 秒, 06 年 -7 时区
 </description>
        </item>
        <item>
        <title>VBA 笔记</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/excel/vba-notebook/</link>
        <pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/excel/vba-notebook/</guid>
        <description>VBA(For Excel) Excel 单元格内容格式 单元格里的数据类型系统是根据数据内容确定的, 比如：你将 A 列单元格格式设为保留两位的数值型, 当你在 A1 输入 5 时, 它就显示为 5.00, 如果输入 ABC, 它就不会变成数值型, 而是文本型, 如果将文本改为数字后, 又回到你设置的保留两位小数格式所以单元格设置格式只能对能转换的数据有效(当你设置为文本型后，所有输入字符都能转换为文本，可以理解为文本型才是单元格真正能设置的格式)
相对地址 &amp;amp; 绝对地址($) 在单元格引用中, $表示 绝对引用, 绝对引用能够在自动填充和复制粘贴时保持引用单元格的绝对位置
如果C2单元格值为 =A2*B2, 自动填充后, C3单元格值为 =A3*B3
如果C2单元格值为 =$A$2*B2, 自动填充后, C3单元格值为 =$A$2*B3
引用单元格   A1 表示法
Range(&amp;ldquo;A1&amp;rdquo;)
Range(&amp;ldquo;A1:B5&amp;rdquo;)
Range(&amp;ldquo;A1:B5,C1:D5&amp;rdquo;)
Range(&amp;ldquo;A:A&amp;rdquo;)
Range(&amp;ldquo;1:1&amp;rdquo;)
Range(&amp;ldquo;A:C&amp;rdquo;)
Range(&amp;ldquo;1:5&amp;rdquo;)
Range(&amp;ldquo;1:1,3:3,8:8&amp;rdquo;)
Range(&amp;ldquo;A:A,C:C,F:F&amp;rdquo;)
  索引编号(适合用于循环)
Cells(6, 1)
  快捷表示法
[A1:B5]
  相对引用
Offset(Row, Col)
  Range 表示连续的区域有两种表达:  Range(&amp;ldquo;起始单元格&amp;rdquo;,&amp;ldquo;结束单元格&amp;rdquo;) Range(&amp;ldquo;起始单元格:结束单元格&amp;rdquo;)  Range 表示非连续的区域: Range(&amp;quot;A1:A2, B3:B4&amp;quot;).</description>
        </item>
        <item>
        <title>Csharp 调用外部exe</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/dotnet/csharp-call-command-line/</link>
        <pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/dotnet/csharp-call-command-line/</guid>
        <description>C# 中可以通过 Diagnostics.Process 类来实现调用外部的可执行文件
下面是一段调用 PowerPoint 演示幻灯片的脚本:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  using System.Diagnostics; namespace awake { class Program { static void Main(string[] args) { Process p = new Process(); // powershell 的命令行工具  p.StartInfo.FileName = &amp;#34;C:\\Program Files (x86)\\Microsoft Office\\Office16\\POWERPNT.EXE&amp;#34;; // /S 后面跟着命令的参数  p.StartInfo.Arguments = &amp;#34;/S \&amp;#34;E:\\mail\\keep awake.pptx\&amp;#34;&amp;#34;; p.StartInfo.CreateNoWindow = true; p.StartInfo.UseShellExecute = false; p.Start(); } } }   </description>
        </item>
        <item>
        <title>7z 命令行使用</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/7z-cli-extract-zip/</link>
        <pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/7z-cli-extract-zip/</guid>
        <description>7z 命令行基本语法为
1  7z &amp;lt;command&amp;gt; [&amp;lt;switch&amp;gt;...] &amp;lt;base_archive_name&amp;gt; [&amp;lt;arguments&amp;gt;...]   通配符 *.txt: means all files with an extension of &amp;ldquo;.txt&amp;rdquo; ?a*: means all files with a second character of &amp;ldquo;a&amp;rdquo; *1*: means all names that contains character &amp;ldquo;1&amp;rdquo; *.*.*: means all names that contain two at least &amp;ldquo;.&amp;rdquo; characters
commands l (List) 列出压缩文件中的所有内容
1  7z l archive.zip   a (Add) 1 2 3 4 5 6 7 8 9  7z a -tzip archive.</description>
        </item>
        <item>
        <title>TOML 配置文件</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/toml/</link>
        <pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/toml/</guid>
        <description>规格  TOML 是大小写敏感的 TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档 空白是指制表符(0x09)或空格(0x20) 换行是指 LF(0x0A)或 CRLF(0x0D 0x0A) 使用 # 符号作为注释  键值对 TOML 文档最基本的构成区块是键值对, 键名和键值周围的空白会被忽略
多次定义同一个key是非法的
1  key = &amp;#34;value&amp;#34;   点分隔符 1 2 3 4  name = &amp;#34;Orange&amp;#34; physical.color = &amp;#34;orange&amp;#34; physical.shape = &amp;#34;round&amp;#34; site.&amp;#34;google.com&amp;#34; = true # 引号内的点不会作为分隔符   等价于
1 2 3 4 5 6 7 8 9 10  { &amp;#34;name&amp;#34;: &amp;#34;Orange&amp;#34;, &amp;#34;physical&amp;#34;: { &amp;#34;color&amp;#34;: &amp;#34;orange&amp;#34;, &amp;#34;shape&amp;#34;: &amp;#34;round&amp;#34; }, &amp;#34;site&amp;#34;: { &amp;#34;google.</description>
        </item>
        <item>
        <title>更改xlsm文件中的宏脚本编码</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/dotnet/convert-xlsm-macro-encoding/</link>
        <pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/dotnet/convert-xlsm-macro-encoding/</guid>
        <description>之前任职于一家台湾公司, 公司员工电脑默认的默认编码格式使用的是港台地区的 Big5 编码, 俗称 大五码, 且员工没有管理员权限, 不能修改, 而服务器使用的编码是GBK
由于VBA年代比较久, 使用的还是代码页表示不同语言的字符集(GBK的代码页 936, Big5 的代码页面 950), 没有使用Unicode, 当在员工电脑录制编写的VBA脚本, 保存在xlsm文件中, 需要放到服务器上去执行时, 中文部分会显示乱码
于是, 编写了下面这段代码来转换xlsm文件中的VBA脚本编码, 主要做了以下事情
 将xlsm文件中的VBA代码导出为.bas代码文件 转换纯文本代码文件的编码格式(big5改为GBK) 将转换编码之后的代码导入xlsm文件 生成exe后, 可以通过命令行执行, 也可以直接拖动图标将xlsm文件拖到生成的.exe文件上  如果有需求要批量导出xlsm文件中的脚本代码, 下面的代码修改一下也可以实现
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  using System; using System.</description>
        </item>
        <item>
        <title>Nginx 反向代理中的路径问题</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/nginx-proxy-pass/</link>
        <pubDate>Wed, 24 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/nginx-proxy-pass/</guid>
        <description>Nginx 反向代理的配置块内容通常如下:
1 2 3  location [ = | ~ | ~* | ^~ ] uri { proxy_pass URL; }   proxy_pass 后面的 URL, 如果带 /, 表示绝对路径, 如果不带 /, 表示相对路径
通常 URL = host[:port][path](中括号内的内容表示可选)
如 https://www.example.com:8080/,
https:// 是协议, www.example.com 是 host, 80 是 port, / 是 path
  proxy_pass 后面的 URL 不包含 path 时, 如 https://www.example.com:8080
target_url = URL + uri
  proxy_pass 后面的 URL 包含 path 时, (/也算)(如 https://www.</description>
        </item>
        <item>
        <title>关于SSH长时间无操作自动断开</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/ssh-timeout/</link>
        <pubDate>Fri, 19 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/ssh-timeout/</guid>
        <description>使用 ssh 客户端远程连接到服务器时, 默认情况下, 一段时间不操作, 没有向服务器发送指令, 就自动断开了连接, 需要重新登录
使用过的客户端中, xshell 默认情况下是会自动发送心跳来保持连接, 其他的一些如 mobaxterm, windterm, windows terminal自带的ssh, 时间久没有操作都是会断开连接的, 需要手动设置, 以下是手动设置的方法
 命令行参数设置  如果是在终端中使用ssh命令连接远程机器, 如在Windows Terminal中, 可以通过添加以下参数来设置每隔60秒向Server端发送一个空包以保持连接
1  ssh -o ServerAliveInterval=60 root@127.0.0.1   使用以上参数只会对本次连接会话有效, 如果需要每次都自动保持连接, 可以使用下面的方法
客户端.ssh/config文件设置  ~/.ssh/config 文件中添加ServerAliveInterval 60
Host xxx HostName 127.0.0.1 User root ServerAliveInterval 60 </description>
        </item>
        <item>
        <title>bilibili 视频 shortcode 测试</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/bilibili-video-test/</link>
        <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/bilibili-video-test/</guid>
        <description>测试 hugo 主题 stack 中的 bilibili 视频 shortcode
</description>
        </item>
        <item>
        <title>Hugo 文章中的图片显示问题</title>
        <link>https://frank2016ma.github.io/seattle/posts/hugo/hugo-image/</link>
        <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/hugo/hugo-image/</guid>
        <description>问题 初次尝试使用 Hugo 写一篇带图片的文章时, 遇到如下问题:
文件放在路径 /static/image/ 下, markdown 文件中的路径是![](/image/image1.png)
使用命令 hugo server 生成站点时, 可以在生成的页面中看到
  但是发布到 Github Pages 或者 Nginx 生成静态网站时, 不会显示图片
文件放在路径 /static/image/ 只是 hugo 的约定
解决办法 新建文章时候, 直接新建 文件夹, 内容写在 index.md 中, 图片文件放在同名文件夹下面
content └── post └── my-first-post ├── index.md ├── image1.png └── test.png  ![Alt text](test.png)
渲染如下:
 这样的好处是, 不论是使用 hugo server 生成静态页面文件还是发布到 Github Pages, 或是使用 markdown 编辑器的预览功能, 都可以渲染图片</description>
        </item>
        <item>
        <title>MIME</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/mime/</link>
        <pubDate>Fri, 28 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/mime/</guid>
        <description>MIME 类型 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。
MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。
浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。
语法 MIME 类型通用结构：
 type/subtype
 MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 / 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。
MIME类型对大小写不敏感，但是传统写法都是小写。
两种主要的 MIME 类型在默认类型中扮演了重要的角色：
 text/plain 表示文本文件的默认值。 application/octet-stream 表示所有其他情况的默认值。   摘自 MIME 类型 | 菜鸟教程</description>
        </item>
        <item>
        <title>Grep 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/grep-cheat-sheet/</link>
        <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/grep-cheat-sheet/</guid>
        <description>介绍 rep - print lines that match patterns
语法 grep searches for PATTERNS in each FILE. PATTERNS is one or more patterns separated by newline characters, and grep prints each line that matches a pattern. Typically PATTERNS should be quoted when grep is used in a shell command.
A FILE of “-” stands for standard input. If no FILE is given,recursive searches examine the working directory and nonrecursive searches read standard input.</description>
        </item>
        <item>
        <title>Powershell 删除重复文件脚本</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-remove-duplicate-files/</link>
        <pubDate>Thu, 27 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-remove-duplicate-files/</guid>
        <description>1 2 3  $root_path = &amp;#34;D:\folder_name&amp;#34; $log_file = &amp;#34;D:\log_file.txt&amp;#34; ls $root_path -recurse | get-filehash | group -property hash | where { $_.count -gt 1 } | % { $_.group } | epcsv $log_file   </description>
        </item>
        <item>
        <title>Find 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/find-cheat-sheet/</link>
        <pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/find-cheat-sheet/</guid>
        <description>Usage  search for files in a directory hierarchy
 1  find [path...] [options] [expression]   An expression is composed of a sequence of things:
 Tests Actions Global options Positional options Operators   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # Wildcard find . -name &amp;#34;*.txt&amp;#34; find . -name &amp;#34;2020*.csv&amp;#34; find . -name &amp;#34;json_*&amp;#34; # regex # TODO # directory find .</description>
        </item>
        <item>
        <title>Tmux 速查表</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/tmux/</link>
        <pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/tmux/</guid>
        <description>1 2 3 4 5 6 7 8  # 新建会话 tmux new -s session_name # Attach to last session tmux a # Attach to a session with the name mysession tmux a -t mysession   常用快捷键 将当前会话与窗口分离
Ctrl+b d
列出当前所有会话(此快捷键需要在tmux会话内执行)
Ctrl+b s
划分左右两个窗格
Ctrl+b %
划分上下两个窗格
Ctrl+b &amp;quot;
关闭当前窗格
Ctrl+b x
调整窗格大小 Ctrl+b Ctrl+方向键
copy mode 进入窗口之后不支持上下翻页, 使用以下快捷键进入 copy mode
Ctrl+b [
按 q 退出
参考 Tmux Cheat Sheet &amp;amp; Quick Reference</description>
        </item>
        <item>
        <title>Win11 笔记本亮度调节</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/win11-brightness/</link>
        <pubDate>Wed, 12 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/win11-brightness/</guid>
        <description>Windows11 系统的笔记本电脑在使用电源时, 会出现偶尔屏幕变暗又恢复的情况
解决方法:
打开 设置 &amp;gt; 系统 &amp;gt; 屏幕, 点击亮度调节 右侧下拉选项, 取消勾选 通过优化显示的内容和亮度降低电池能耗</description>
        </item>
        <item>
        <title>Microsoft Excel 横向滚动</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/microsoft-excel-scroll/</link>
        <pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/microsoft-excel-scroll/</guid>
        <description>浏览器 WPS Office 及及大部分支持横向滚动的桌面端软件, 支持 Shift + 鼠标滚轮 实现横向滚动
Microsoft Office 的 Excel 横向滚动的方式是 Ctrl + Shift + 鼠标滚轮</description>
        </item>
        <item>
        <title>tldr - 更加简洁的帮助文档</title>
        <link>https://frank2016ma.github.io/seattle/posts/linux/tldr-cheat-sheet/</link>
        <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/linux/tldr-cheat-sheet/</guid>
        <description>简介 tldr(Too Long; Didn&amp;rsquo;t Read) 是一个开源的命令行工具，提供简洁的命令行使用文档
tldr 提供了 web端 tldr InBrowser.App, nodejs 和 python 客户端以及 PDF版本
安装 1 2 3 4 5 6  # nodejs npm install tldr # python pip3 install tldr   使用 tldr sed sed Edit text in a scriptable manner. See also: `awk`, `ed`. More information: https://www.gnu.org/software/sed/manual/sed.html. - Replace all `apple` (basic regex) occurrences with `mango` (basic regex) in all input lines and print the result to `stdout`: command | sed &#39;s/apple/mango/g&#39; - Execute a specific script [f]ile and print the result to `stdout`: command | sed -f path/to/script.</description>
        </item>
        <item>
        <title>Gpt_Mirror</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/gpt_mirror/</link>
        <pubDate>Sun, 09 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/gpt_mirror/</guid>
        <description>GPT-Mirror</description>
        </item>
        <item>
        <title>Everything Search Tool</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/everything-search-tool/</link>
        <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/everything-search-tool/</guid>
        <description>&amp;ldquo;Everything&amp;rdquo; 是什么？ &amp;ldquo;Everything&amp;rdquo; 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。
如何在运行 &amp;ldquo;Everything&amp;rdquo; 时屏蔽 UAC 警告？ &amp;ldquo;Everything&amp;rdquo; 需要管理员权限以便低级别读取 NTFS 分卷来 NTFS 索引。
UAC 警告可以通过以标准用户运行 &amp;ldquo;Everything&amp;rdquo; 和安装 &amp;ldquo;Everything&amp;rdquo; 服务或不使用 NTFS 索引来避免。
以标准用户运行 &amp;ldquo;Everything&amp;rdquo; 和安装 &amp;ldquo;Everything&amp;rdquo; 服务：
在 &amp;ldquo;Everything&amp;rdquo; 中，打开工具菜单，点击选项。
  点击常规页面。
  检查 Everything 服务。
  取消以管理员方式运行。
  点击确定。
  退出 &amp;ldquo;Everything&amp;rdquo; (右键 Everything 托盘图标并点击退出)。
  重启 Everything。
  搜索 &amp;ldquo;Everything&amp;rdquo; 能否搜索文件内容？ 可以，&amp;ldquo;Everything&amp;rdquo; 可以通过搜索函数 content: 来搜索文件内容。
文件内容未被索引时，搜索内容将会很慢。
如何使用通配符？ 搜索关键词中使用通配符 * 将会匹配任意数量的任意字符。</description>
        </item>
        <item>
        <title>PowerShell 查看历史命令</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-history/</link>
        <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-history/</guid>
        <description>Get-History PowerShell 的 Get-History 命令只显示当前会话的历史命令
关闭当前窗口再打开一个新的PowerShell窗口时, 先前窗口中输入的历史命令无法使用 Get-History 获取到
PowerShell 没有类似 Linux bash 下的 history 一样, 直接查看所有会话的历史命令的 Cmdlet
但是和 bash 一样, PowerShell 将所有会话的命令历史记录存储在文本文件中
这个文件的路径可以通过命令 (Get-PSReadlineOption).HistorySavePath 获取到
Get-PSReadlineOption Get-PSReadlineOption 命令 包含在 PSReadLine 模块下, 该模块需要 PowerShell 5.1 或更高的版本
可以通过以下命令来实现查看所有命令历史记录
1  Get-Content (Get-PSReadlineOption).HistorySavePath    Tips: 如果历史命令中包含中文等非ASCII字符, 需要使用对应的编码读取该文本文件, 否则会显示乱码
 PowerShell 编码 PowerShell 5.1 中 Get-Content 命令的 -Encoding 参数默认是 Default
Default 使用与系统的活动代码页相对应的编码 (通常为 ANSI)
而在 PowerShell 7.2 中, Get-Content 命令的 -Encoding 参数默认是 utf8NoBOM</description>
        </item>
        <item>
        <title>PowerShell 配置文件</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-profile/</link>
        <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-profile/</guid>
        <description>简短说明 介绍如何创建和使用 PowerShell 配置文件
长说明 PowerShell 配置文件是在 PowerShell 启动时运行的脚本。 可以使用配置文件作为启动脚本来自定义环境。 可以添加命令、别名、函数、变量、模块、PowerShell 驱动器等。 还可以将其他特定于会话的元素添加到配置文件中，使其在每个会话中可用，而无需导入或重新创建它们。 PowerShell 支持用户和主机程序的多个配置文件。 但是，它不会为你创建配置文件。
$PROFILE 变量 变量 $PROFILE 存储 当前用户，当前主机 配置文件 的路径。
其他配置文件保存在 变量的注释属性中, 可通过以下命令查看对应类型配置文件的路径
1  $PROFILE | Get-Member -Type NoteProperty   创建、编辑配置文件 1  notepad $PROFILE   如果配置文件首次设置后, 打开 PowerShell 时显示
无法加载文件 C:\Users\Ma\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1，因为在此系统上禁止运行脚本。
需要以管理员身份运行以下脚本, 修改执行策略以允许加载配置文件
1  Set-ExecutionPolicy RemoteSigned   使用配置文件 在 PowerShell 中创建的许多项和运行的大多数命令仅影响当前会话。 结束会话时，将删除这些项。
特定于会话的命令和项包括添加到会话的 PowerShell 变量、环境变量、别名、函数、命令和 PowerShell 模块。
若要保存这些项并使其在所有将来的会话中可用，请将它们添加到 PowerShell 配置文件。</description>
        </item>
        <item>
        <title>VScode 快捷键</title>
        <link>https://frank2016ma.github.io/seattle/posts/others/vscode-keys/</link>
        <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/others/vscode-keys/</guid>
        <description>多光标操作     ====     Ctrl+I 选中当前行   Shift+Alt+I 将光标插入所选每行的末尾   Ctrl+Shift+L 选择所有与所选中内容相同的内容   Ctrl+F2 选择所有与所选中词汇相同的内容    编辑器控制     ====     Ctrl+\ 拆分编辑器为多组   Ctrl+ 1 / 2 / 3 切换窗口焦点至某一组    文件管理     ====     Ctrl+K P 复制当前文件路径   Ctrl+K R 打开当前文件所在文件夹    显示     ====     Shift+Alt+0 切换编辑器布局(水平/垂直)   Ctrl+Shift+F 显示搜索界面   Ctrl+Shift+X 显示插件管理界面   Ctrl+K V 预览 Markdown 文件（侧边）   Ctrl+K Z 禅模式（连按两次 Esc 退出）    语言操作     ====     Ctrl+K Ctrl+X 移除行尾空白字符    基础编辑     ====     Ctrl+Shift+K 删除行   Ctrl+Enter 在当前行下方插入新行   Ctrl+Shift+Enter 在当前行上方插入新行   Shift+Alt+A 切换块注释   Alt+Z 切换自动换行   Ctrl+K Ctrl+[ 折叠当前所有子代码块   Ctrl+K Ctrl+] 展开当前所有子代码块     写文章时经常遇到一些英文名词以及缩写, 需要频繁切换输入法中英文以及大小写, 非常不方便, vscode 自带的命令转换选中内容的功能</description>
        </item>
        <item>
        <title>Bookmarklet</title>
        <link>https://frank2016ma.github.io/seattle/posts/javascript/bookmarklet/</link>
        <pubDate>Mon, 27 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/javascript/bookmarklet/</guid>
        <description>Bookmarklet 是什么 A bookmarklet is a bookmark stored in a web browser that contains JavaScript commands that add new features to the browser. They are stored as the URL of a bookmark in a web browser or as a hyperlink on a web page. Bookmarklets are usually small snippets of JavaScript executed when user clicks on them. When clicked, bookmarklets can perform a wide variety of operations, such as running a search query from selected text or extracting data from a table.</description>
        </item>
        <item>
        <title>Python 100道面试题-摘抄</title>
        <link>https://frank2016ma.github.io/seattle/posts/python/python-meeting/</link>
        <pubDate>Mon, 27 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/python/python-meeting/</guid>
        <description>题目001: 在Python中如何实现单例模式。  点评：单例模式是指让一个类只能创建出唯一的实例，这个题目在面试中出现的频率极高，因为它考察的不仅仅是单例模式，更是对Python语言到底掌握到何种程度，建议大家用装饰器和元类这两种方式来实现单例模式，因为这两种方式的通用性最强，而且也可以顺便展示自己对装饰器和元类中两个关键知识点的理解。
 方法一：使用装饰器实现单例模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from functools import wraps def singleton(cls): &amp;#34;&amp;#34;&amp;#34;单例类装饰器&amp;#34;&amp;#34;&amp;#34; instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President: pass    扩展：装饰器是Python中非常有特色的语法，用一个函数去装饰另一个函数或类，为其添加额外的能力。通常通过装饰来实现的功能都属横切关注功能，也就是跟正常的业务逻辑没有必然联系，可以动态添加或移除的功能。装饰器可以为代码提供缓存、代理、上下文环境等服务，它是对设计模式中代理模式的践行。在写装饰器的时候，带装饰功能的函数（上面代码中的wrapper函数）通常都会用functools模块中的wraps再加以装饰，这个装饰器最重要的作用是给被装饰的类或函数动态添加一个__wrapped__属性，这个属性会将被装饰之前的类或函数保留下来，这样在我们不需要装饰功能的时候，可以通过它来取消装饰器，例如可以使用President = President.__wrapped__来取消对President类做的单例处理。需要提醒大家的是：上面的单例并不是线程安全的，如果要做到线程安全，需要对创建对象的代码进行加锁的处理。在Python中可以使用threading模块的RLock对象来提供锁，可以使用锁对象的acquire和release方法来实现加锁和解锁的操作。当然，更为简便的做法是使用锁对象的with上下文语法来进行隐式的加锁和解锁操作。
 方法二：使用元类实现单例模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class SingletonMeta(type): &amp;#34;&amp;#34;&amp;#34;自定义单例元类&amp;#34;&amp;#34;&amp;#34; def __init__(cls, *args, **kwargs): cls.</description>
        </item>
        <item>
        <title>Powershell 笔记</title>
        <link>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-basic/</link>
        <pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/posts/windows/powershell/powershell-basic/</guid>
        <description>Get-Content 将从文件读取的数据视为数组, 每行文件内容为一个数组元素
传统的Cmd管道是基于文本的, 但是Powershell是基于对象的.
  为什么可以通过notpad打开记事本, 不能通过wordpad打开写字板？
因为notepad.exe位于C:Windows\system32这个目录, 而这个目录已经默认被包含在Powershell的环境变量$env:Path中.
而wordpad.exe所在的%ProgramFiles%\Windows NT\Accessories目录却没有包含,
将wordpad所在的目录加入到环境变量中, $env:Path=$env:Path+&amp;quot;%ProgramFiles%\Windows NT\Accessories&amp;quot;.
  常用的对管道结果进一步处理的命令有：
   命令 解释     Compare-Object 比较两组对象.   ConvertTo-Html 将 Microsoft .NET Framework 对象转换为可在 Web 浏览器中显示的 HTML.   Export-Clixml 创建对象的基于 XML 的表示形式并将其存储在文件中.   Export-Csv 将 Microsoft .NET Framework 对象转换为一系列以逗号分隔的、长度可变的 (CSV) 字符串, 并将这些字符串保存到一个 CSV 文件中.   ForEach-Object 针对每一组输入对象执行操作.   Format-List 将输出的格式设置为属性列表, 其中每个属性均各占一行显示.   Format-Table 将输出的格式设置为表.</description>
        </item>
        <item>
        <title>Categories</title>
        <link>https://frank2016ma.github.io/seattle/categories/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/categories/</guid>
        <description></description>
        </item>
        <item>
        <title>Search</title>
        <link>https://frank2016ma.github.io/seattle/search/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://frank2016ma.github.io/seattle/search/</guid>
        <description></description>
        </item>
        
    </channel>
</rss>
